## 面试自我介绍

面试官你好，我叫王世茂，18年毕业于安徽三联学院，曾在18年7月份就职杭州魔厨科技有限公司，做web前端开发工程师，主要负责移动端webApp项目和PC端官网页面，负责公司的后台管理系统页面的更新和维护，和同事一起对已有项目进行更新迭代、维护，以及活动页的编写，根据用户反馈及时和公司同事一起优化页面，解决问题

## 公司地点：

浙江省杭州市西湖区文一西路98号数娱大厦316室

马路对面是浙江财经大学（文华校区）

## 老板：

李卓林

## 成立于

2011年06月24日

## 经营范围包括服务：

网络技术、电子商务技术的技术开发，设计、制作、代理、发布国内广告（除网络广告发布），增值电信业务，经营性互联网文化服务

上个公司工资11000

五险一金按标准

最终8300多

小厨说   项目时间  18-10 

网上厨房厨艺  项目时间   19-4

开发过程中遇到的问题：

​		单词写错和调用时名称

​		一些基础的点忘记，比如有的表签自带样式，有些异步操作获取dom节点获取不到



## Vue是什么：

1、vue是基于js的mvvm渐进式视图框架

2、从历史潮流来说，人们从之前的原生js->jquery库-> 前端模板引擎，他们都有一个共同点就是需要我们去操作dom 而vue和上面的这些不一样它能够帮助我们减少不必要的Dom操作；提高渲染效率，采用双向数据绑定 （通过框架提供的指令，我们前端程序员只需要关心数据的业务逻辑，不再关心dom是如何渲染的了）

2、vue作为前端框架的特点

  构建用户界面，只需要关系view层

  简单易学，轻量快速

  渐进式框架

3、vue的两个核心

 响应式的数据绑定：当数据发生改变，视图可以自动更新，可以不用关心dom操作，而专心数据操作

 可以组合的视图组件：把视图按照功能切分成若干份基本单元，组件可以一级一级组合整个用形成倒置组件树，可维护，可重用，可测试

 

## Ajax是什么：

一般情况下，前端和后台进行交互都需要页面跳转才能获取到新的数据，然后重新跳转到一个页面，将数据加载到页面上。这对资源的消耗很大，用户体验感也不是很好。

所以js提供了一个不需要刷新页面就能加载后台数据的技术：AJAX

AJAX可以<font color="red">不刷新页面</font>发送http请求，接收到服务器给客户端的数据。

AJAX，全称：`async javascript and XML`，是一个异步执行的和后台交互的技术。

**Ajax****封装：**

· ajax技术的核心是XMLHttpRequest对象,其通过创建一个XMLHttpRequest对象，利用对象的open方法发送请求，判断对象中readyState属性(请求、响应过程的当前活动阶段)的值和status(Http的响应状态)的值，得到responseText等 

· open方法的三个参数 

- 第一个参数：请求方式
- 第二个参数：请求的URL
- 第三个参数：是否异步(大多数使用异步请求)

· readyState属性的值 

- 0：未初始化。尚未调用open()方法
- 1：启动。已经调用open()方法，但尚未调用send()方法。
- 2：发送。已经调用send()方法，但尚未接收到响应。
- 3：接收。已经接收到部分响应数据。
- 4：完成。已经接收到全部响应数据，而且已经可以在客户端使用了。

· status属性的值 

- 成功：(>=     200 && < 300) || === 304
- 失败：除去成功的情况

 

**如何解决跨域？ 能说1，2，7，8就行。**

1、 通过jsonp跨域  利用script标签的src属性来实现跨域。通过将前端方法作为参数传递到服务端，然后由服务器注入参数再返回，实现服务端向客户端通信  不支持post请求

2、CORS 代理 Access-Control-Allow-Origin:*  服务端设置  指定可获取数据额域名

3、 document.domain + iframe跨域

4、 location.hash + iframe

5、 window.name + iframe跨域

6、 postMessage跨域

7、 nginx代理跨域   配置location proxy——pass配置域名 Proxy_redirect配置重定向

8、 nodejs中间件代理跨域

9、 WebSocket协议跨域

 

**Es6****新增的方法**

1、    定义变量

2、    函数形参的默认值

3、    模板字符串

4、    解构赋值

5、    展开运算符

6、    对象的简写

7、    字符串方法

8、    检测数据类型

9、    This关键字

10、  箭头函数

 

**This****代表**

1、 普通函数 – window

2、 定时器 – window

3、 自调用函数 – window

4、 对象方法中 – 这个方法的对象

5、 事件函数 – 代表事件源

6、 箭头函数 – 上一行代码的this

 

改变this指向的方法与区别

方法：1、call apply  bind

区别：**call****和apply****都可以改变this****指向**，不过apply的第二个参数是散列分布，call则可以是一个数组

 

**Vue****的八个生命周期钩子：**

1，挂载阶段

 beforeCreate

  此时 数据还没有完成监听 （操作数据 无响应） 基本不用

 created

  此时 组件的属性和方法已经 可用，且 数据已经监听完毕（所以在这里可以操作数据了）

 beforeMount

  dom挂载之前 （此时当前组件的 dom还未挂载，所以无法获取dom）

 mounted

  dom挂载完毕 此时 已经可以获取当前组件的dom

 

2，更新 阶段

 beforeUpdate

  数据改变 dom更新之前

 updated

  数据改变 dom已经 更新完成 在这里可以获取 最新的dom

3，销毁 

 beforeDestroy 销毁之前

 destroyed  已经销毁

 销毁时：使用较多的是 beforeDestroy

   在这里 注销 当前组件中在window下 注册的 事件监听 

   取消 当前组件中的定时器



**小程序生命周期**

 应用的生命周期：

| **属性** | **类型** | **描述**                       | **触发时机**                                            |
| -------- | -------- | ------------------------------ | ------------------------------------------------------- |
| onLaunch | Function | 生命周期函数--监听小程序初始化 | 当小程序初始化完成时，会触发 onLaunch（全局只触发一次） |
| onShow   | Function | 生命周期函数--监听小程序显示   | 当小程序启动，或从后台进入前台显示，会触发 onShow       |
| onHide   | Function | 生命周期函数--监听小程序隐藏   | 当小程序从前台进入后台，会触发 onHide                   |

 

1、用户首次打开小程序，触发 onLaunch（全局只触发一次）。
 2、小程序初始化完成后，触发 onShow 方法，监听小程序显示。
 3、小程序从前台进入后台，触发 onHide 方法。
 4、小程序从后台进入前台显示，触发 onShow 方法。
 5、小程序后台运行一定时间，或系统资源占用过高，会被销毁。

 

 

| **属性** | **类型** | **描述**                           |
| -------- | -------- | ---------------------------------- |
| data     | Object   | 页面的初始数据                     |
| onLoad   | Function | 生命周期函数--监听页面加载         |
| onReady  | Function | 生命周期函数--监听页面初次渲染完成 |
| onShow   | Function | 生命周期函数--监听页面显示         |
| onHide   | Function | 生命周期函数--监听页面隐藏         |
| onUnload | Function | 生命周期函数--监听页面卸载         |


 1、小程序注册完成后，加载页面，触发 onLoad 方法。
 2、页面载入后触发 onShow 方法，显示页面。
 3、首次显示页面，会触发 onReady 方法，渲染页面元素和样式，一个页面只会调用一次。
 4、当小程序后台运行或跳转到其他页面时，触发 onHide 方法。
 5、当小程序有后台进入到前台运行或重新进入页面时，触发 onShow 方法。
 6、当使用重定向方法 wx.redirectTo(OBJECT) 或关闭当前页返回上一页 wx.navigateBack()，触发 onUnload。


 总结：
 **1****、onLoad: 页面加载。**
 a、一个页面只会调用一次。
 b、参数可以获取wx.navigateTo和wx.redirectTo及<navigator/>中的 query。
 **2****、onShow: 页面显示。**
 a、每次打开页面都会调用一次。
 **3****、onReady: 页面初次渲染完成。**
 a、一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。
 b、对界面的设置如wx.setNavigationBarTitle请在onReady之后设置。详见[生命周期](https://link.jianshu.com?t=https:/mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/page.html?t=1475052056377#生命周期)
 **4****、onHide: 页面隐藏。**
 a、当navigateTo或底部tab切换时调用。
 **5****、onUnload: 页面卸载。**
 a、当redirectTo或navigateBack的时候调用。

 

​    **数据请求的四种方式**

Ajax原生数据请求  

​       隶属于原生js中 核心使用XMLHttpRequest对象，多个请求之间如果有先后顺序就会出现回调地狱 后面的ajax封装可以使用基于promise来封装

 

Jquery中的ajax请求

​       由于jquery是基于原始的基础上做的封装，所以，juqery ajax也是原始ajax封装

 

Fetch数据请求

​       原生javascript提供的  可以直接全局变量使用

​       Fetch也是Promise

​       返回的数据是没有进行封装的 

​       数据格式化的方式  json（） text（） Blob（）格式化二进制

 

Vue axios数据请求

​       Axios底层封装的Promise

​       Axios会将我们请求的数据进行一层封装       

 

## 数组去重方法   

**Methods 1**: 思路：定义一个新数组，并存放原数组的第一个元素，然后将元素组一一和新数组的元素对比，若不同则存放在新数组中。

**Methods 2:** 思路：先将原数组排序，在与相邻的进行比较，如果不同则存入新数组。

 **Methods 3**: 利用对象属性存在的特性，如果没有该属性则存入新数组。

**Methods 4:** 利用数组的indexOf下标属性来查询。

**Methods 5**: 利用数组原型对象上的includes方法。判断字符串和数组是否有某个指定的值

**Methods 7**: 利用数组原型对象上的 forEach 和 includes方法。

**Methods 6**: 利用数组原型对象上的 filter 和 includes方法。

**Methods 8**: 利用数组原型对象上的 splice 方法。

**Methods 9**: 利用数组原型对象上的 lastIndexOf 方法。

七、[…new Set(arr)] 严格来说是第一种方法的简化

​        

弹性盒模型

盒模型是css布局的基石，它规定了网页元素如何显示以及元素间相互关系。css定义所有的元素都可以拥有像盒子一样的外形和平面空间。即都包含内容区、补白（填充）、边框、边界(外边距)这就是盒模型。

是一种当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为的布局方式。

引入弹性盒布局模型的目的是提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间。

弹性容器通过设置 display 属性的值为 flex 或 inline-flex将其定义为弹性容器。     



## 简单说下原型链？

每个函数都有 `prototype` 属性，除了 `Function.prototype.bind()`，该属性指向原型。

每个对象都有 `__proto__` 属性，指向了创建该对象的构造函数的原型。其实这个属性指向了 `[[prototype]]`，但是 `[[prototype]]`是内部属性，我们并不能访问到，所以使用 `_proto_`来访问。

对象可以通过 `__proto__` 来寻找不属于该对象的属性，`__proto__` 将对象连接起来组成了原型链。

## jQuery给我们提供了4种制作动画的方式

show/down

fadeln/fadeOut

slideDown/slideUp

animate/stop

## css3动画样式

@keyframes规则

​	tranfrom

​	transition

​	animation

## vue路由跳转：

## 组件通讯

父子通信  通过自定义标签属性传递，可传递动态数据 需加：属性  子组件中定义props属性接收父组件传递的数据 -- 数组（props验证）

子-->父通讯   通过自定义事件完成   子--this.$emit('自定义事件'，携带参数)   父组件中 -- <child @自定义事件名=“函数”></child>

兄弟组件通讯  通过事件中心总线  eventBus  创建一个第三方的实例

不常用

  ref组件通讯；

  this.$parent   -- 父组件实例

​	this.$children   -- 所有子组件实例  数组 放多个子组件实例；

​	provide    inject



## 问题一：构建的 vue-cli 工程都到了哪些技术，它们的作用分别是什么？

- `vue.js`：`vue-cli`工程的核心，主要特点是 双向数据绑定 和 组件系统。
- `vue-router`：`vue`官方推荐使用的路由框架。
- `vuex`：专为 `Vue.js` 应用项目开发的状态管理器，主要用于维护`vue`组件间共用的一些 变量 和 方法。
- `axios`（ 或者 `fetch` 、`ajax` ）：用于发起 `GET` 、或 `POST` 等 `http`请求，基于 `Promise` 设计。
- `vuex`等：一个专为`vue`设计的移动端`UI`组件库。
- 创建一个`emit.js`文件，用于`vue`事件机制的管理。
- `webpack`：模块加载和`vue-cli`工程打包器。

## 问题二：vue-cli 工程常用的 npm 命令有哪些？

- 下载 `node_modules` 资源包的命令：

```text
npm install
```

- 启动 `vue-cli` 开发环境的 npm命令：

```text
npm run dev
```

- `vue-cli` 生成 生产环境部署资源 的 `npm`命令：

```text
npm run build
```

- 用于查看 `vue-cli` 生产环境部署资源文件大小的 `npm`命令：

```text
npm run build --report
```

> 在浏览器上自动弹出一个 展示 `vue-cli` 工程打包后 `app.js`、`manifest.js`、`vendor.js` 文件里面所包含代码的页面。可以具此优化 `vue-cli` 生产环境部署的静态资源，提升 页面 的加载速度

npm -v   查看npm版本

npm -ls 查看当前安装包的依赖关系

npm i -g(全局)   -S(生产环境下载)  -D(生产环境不下载)  

## ajax、axios、fetch区别

ajax优缺点：

- 本身是针对`MVC`的编程,不符合现在前端`MVVM`的浪潮
- 基于原生的`XHR`开发，`XHR`本身的架构不清晰，已经有了`fetch`的替代方案
- `JQuery`整个项目太大，单纯使用`ajax`却要引入整个`JQuery`非常的不合理（采取个性化打包的方案又不能享受CDN服务）

axios优缺点：

- 从浏览器中创建 `XMLHttpRequest`
- 从 `node.js` 发出 `http` 请求
- 支持 `Promise API`
- 拦截请求和响应
- 转换请求和响应数据
- 取消请求
- 自动转换`JSON`数据
- 客户端支持防止`CSRF/XSRF`

fetch优缺点：

- `fetcht`只对网络请求报错，对`400`，`500`都当做成功的请求，需要封装去处理
- `fetch`默认不会带`cookie`，需要添加配置项
- `fetch`不支持`abort`，不支持超时控制，使用`setTimeout`及`Promise.reject`的实现的超时控制并不能阻止请求过程继续在后台运行，造成了量的浪费
- `fetch`没有办法原生监测请求的进度，而XHR可以

## 二次封装axios

首先在项目路径下创建axios文件夹 ，在axios文件夹里新建api.js和request.js api.js写接口，对axios的封装写在request.js里

然后开始统一封装axios，首先引入axios、qs、依赖main.js可根据个人需求引入  比如调接口的时候显示loading

然后创建axios实例，设置baseURL和请求超时时间

实例创建好之后开始使用request拦截器对axios请求配置做统一处理，请求方式  请求参数  请求头   请求错误的处理

然后是对response做统一处理   处理后端返回来的数据  响应错误的处理

axios接口调用  

注意：post请求参数放在data里面，get请求参数放在params里。

## vuex作用

Vuex 是一个专为 Vue.js 应用程序开发的**状态管理模式**。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。

`state`: 状态中心

`mutations`: 更改状态

`actions`: 异步更改状态

`getters`: 获取状态

`modules`: 将`state`分成多个`modules`，便于管理

## MVVM原理   

  当我们 创建一个实例 （new Vue），需要传入data，data值是对象，vue会去遍历data这个对象的所有的属性，用Object.defineProperty()劫持，转换成getter和setter(就是Object.defineProperty参数中的get和set方法)，每一个getter和setter中 放置一个监听者，每一个getter和setter调用时，会触发监听者 监听的事件,监听回调函数就会触发，在这个回调函数中 触发了render函数 ，render触发会 重新生成 虚拟dom和数据未修改前的在内存中存储的上一次的虚拟dom树进行比较（diff算法），得到最优的一种方案来更新真实dom，再将更新后的dom结构用虚拟dom保存，更新内存中存储虚拟dom

## 什么是虚拟dom？

它是一个object对象模型 用来模拟真实的dom

数据更新，dom更新，每一次都会在内存中存储一份，当前真实dom对应虚拟dom（包括第一次加载）
    直接操作dom是很耗性能的，所以我们在数据改变后，不会直接修改真实dom树，而是先调用render函数，生成 最新的 虚拟dom结构，和数据未修改前的在内存中存储的上一次的虚拟dom树进行比较（diff算法），得到最优的一种方案来更新真实dom，再将更新后的dom结构用虚拟dom保存，更新内存中存储虚拟dom

vdom是高效的渲染页面 减少不必要的dom操作 提高渲染效率

## 什么是diff算法？

 diff 让dom树，逐层进行比较（一层对一层（1---1   2---2））
      如果每一层 虚拟dom还有独一无二key值，按照，这一层的相同key进行比较（相当于电影院中座位号（几排几号）），所以在做循环 v-for 时，一定要给循环每一项加 独一无二key（提高diff算法比较效率，更快渲染真实dom）



## 函数柯里化

> 在一个函数中，首先填充几个参数，然后再返回一个新的函数的技术，称为函数的柯里化。通常可用于在不侵入函数的前提下，为函数 预置通用参数，供多次重复调用。

## vue 和 react 区别

- 相同点：都支持 `ssr`，都有 `vdom`，组件化开发，实现 `webComponents` 规范，数据驱动等
- 不同点：`vue` 是双向数据流（当然为了实现单数据流方便管理组件状态，`vuex` 便出现了），`react` 是单向数据流。`vue`的 `vdom` 是追踪每个组件的依赖关系，不会渲染整个组件树，`react` 每当应该状态被改变时，全部子组件都会 `re-render`

### 为什么用 vue

> 简洁、轻快、舒服

## 闭包

javascript闭包就是在另一个作用域中保存了一份它从上一级函数或作用域取得的变量（键值对），而这些键值对是不会随上一级的执行完成而销毁

同源策略

跨域

## git版本控制

```
git init  创建git库
git status 查看当前仓库的状态
git diff 常看本次修改与上次需改的内容的区别
git add 文件名 把现在所要添加的文件放到暂存区中
git commit 把git add到暂存区的容器提交到代码区中
git clone 从远程仓库拷贝代码到本地
git branch 查看当前的分支名称
git checkout 切换分支

什么是版本控制：
它是一个记录文件变化的系统，以便你以后可以调用特定版本的文件。版本控制允许你：
将文件还原为以前的状态。
将整个项目还原为以前的状态。
比较一段时间内的变化。
查看最后一次修改可能导致问题的内容。
何时引入了问题。
好处：所有团队成员都可以随时在任何文件上自由工作
如果中央服务器出现问题可以使用任何团队的本地git储存库来恢复代码

Git 是一个分布式版本控制系统（DVCS），它可以跟踪文件的更改，并允许你恢复任何特定的更改
```



## rem布局原理

## rem：相对于根元素(即 html 元素)font-size 计算值的倍数。



## 工作中遇到的问题：

## 缺点：

在生活上我遇到一些不对的人或事，容易提出不同的意见，有些意见由于不太中听，导致会得罪一些人，但是我在提出建议的时候会尽量注意场合和方式，也一直遵循一个原则就是四不过三

工作学习上，就是我对前端的好多知识点没有系统的梳理，有些技术一段时间不用就容易忘记，但这个问题我应该最近就能解决 ，毕竟只是有些遗忘，在重新看的时候很容易就能理解记住

优点：

## 求知欲：工作和学习上遇到不懂或者bug这种我就比必须把这个问题彻底弄懂，就是知道这个问题为什么会出现，为什么这么解决

抗压能力强：这个是我从小时候就锻炼出来的，毕竟是农村出身