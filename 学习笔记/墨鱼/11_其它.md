# 一篇文章搞定 javascript 正则表达式

## [#](https://cchroot.github.io/interview/pages/interview notes/一篇文章搞定 javascript 正则表达式.html#前言)前言

正则表达式在平时工作中非常常见，但是它的神奇对于很多程序员可能一直像魔法一样的存在，工作中用到的大部分正则都是去网上搜索得来的，再复杂一点看着文档费时费力的拼凑一下。是不是深有感触了？一次在网上看到有关正则的视频，让我收货颇多，当时认真记录了笔记和自己的感悟，也希望给更多需要的童鞋带来帮助。文章从零开始讲正则，导致有点长，可以收藏零碎时间慢慢看，认真看完绝对受益匪浅。文章首发于[我的博客 (opens new window)](https://cchroot.github.io/)，以下是正文：

Regular Expression 使用单个字符串来描述、匹配一系列符合某个语法规则的字符串。说简单了就是按照某种规则去匹配符合条件的字符串。这里先推荐一个学习正则表达式的在线工具：https://regexper.com/，网站利用图像和英文解释，可以帮助我们非常形象的学习正则表达式，该工具也可以通过github下载安装到本地，例如：一个匹配日期的正则：`^\d{4}[/-]\d{2}[/-]\d{2}$`在工具中是这样显示的：

![img](https://user-gold-cdn.xitu.io/2018/8/8/1651977929920af1?w=487&h=98&f=png&s=9264)

是不是非常直观~

## [#](https://cchroot.github.io/interview/pages/interview notes/一篇文章搞定 javascript 正则表达式.html#regexp对象)RegExp对象

javaScript 中通过内置对象 RegExp 支持正则表达式，有两种方法实例化 RegExp 对象：

1. 字面量
2. 构造函数

### [#](https://cchroot.github.io/interview/pages/interview notes/一篇文章搞定 javascript 正则表达式.html#_1-字面量)1. 字面量

假设你需要把一句英文里面的小写is匹配成大写的 IS，你可以这样做：

```js
var reg = /\bis\b/;
var text = 'He is a boy, This is a dog. Where is she?';
var result = text.replace(reg,'IS');
console.log(result) //He IS a boy, This is a dog. Where is she?
```



这样就把第一个英文单词'is'替换成了'IS'，假如你想把该句中所有的单词'is'都替换成'IS',应该这样写：

```js
var reg = /\bis\b/g;
var text = 'He is a boy, This is a dog. Where is she?';
var result = text.replace(reg,'IS');
console.log(result) //He IS a boy, This IS a dog. Where IS she?
```



在正则的末尾加上'g'就好，'g'表示global，是全局匹配的意思。'g'是正则表达式的一个修饰符，修饰符有:

- 'g': global 全文搜索，不添加，搜索到第一个停止
- 'i': ignore case 忽略大小写，默认大小写敏感
- 'm': multiple 多行搜索 ，检测字符串中的换行符，主要是影响字符串开始标识符^和结束标识符$的使用

可能你会想，为什么句子中的'This'中的is没有被匹配成功呢，这就是我们'\b'的功劳了。

'\b':匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。

这里的正则在'is'的前后都有'\b'，这样就只能匹配单词'is'了。

### [#](https://cchroot.github.io/interview/pages/interview notes/一篇文章搞定 javascript 正则表达式.html#构造函数)构造函数

倘若你需要使用构造函数的方式实例化正则，则上面的字面量形式可以改成这样：

```js
var reg = new RegExp('\\bis\\b','g');
var text = 'He is a boy, This is a dog. Where is she?';
var result = text.replace(reg,'IS');
console.log(result) //He IS a boy, This IS a dog. Where IS she?
```



用这种方式就不需要'/'符号开始和结尾以表示是正则了。但是里面的'\'等特殊字符需要用'\'转义。

'\':将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\n”匹配一个换行符。串行“\\”匹配“\”而“\(”则匹配“(”。

## [#](https://cchroot.github.io/interview/pages/interview notes/一篇文章搞定 javascript 正则表达式.html#元字符)元字符

正则表达式由两种基本字符类型组成：

- 原义文本字符，即代表它原本含义的字符
- 元字符，元字符是在正则表达式中有特殊含义的非字母字符，例如上文提到的'\b'，表示匹配单词边界，并不是匹配'\b'，在正则中主要存在这些特殊字符：`*,+,?,$,^,.,|,\,(,),{,},[,]`

## [#](https://cchroot.github.io/interview/pages/interview notes/一篇文章搞定 javascript 正则表达式.html#字符类-字符集合)字符类（字符集合）

一般情况下，正则表达式一个字符对应字符串一个字符，例如：`ab\t`就是匹配字符串'ab'+'tab'

但是更多的时候，我们匹配的并不是某个字符，而是符合一系列特征的字符串。这时候，我们就可以使用元字符'[]'来构建一个简单的类，所谓类是指符合某些特性的对象，一个泛指，而不是特指某个字符，例如：表达式'[abc]'把字符a或b或c归为一类，表达式可以匹配这样的字符。

```js
var reg = /[abc]/g;
var text = 'a1b2c3d4';
var result = text.replace(reg,'X');
console.log(result); //X1X2X3d4
```



这样我们匹配的就是不是abc这样三个字符了，而是abc中任何一个字符，这就是元字符的一个应用。

### [#](https://cchroot.github.io/interview/pages/interview notes/一篇文章搞定 javascript 正则表达式.html#字符类取反)字符类取反

使用元字符'^'创建 **反向类/负向类**。

反向类的意思是**不属于类的内容**，表达式'[^abc]'表示**不是字符a或b或c**的内容,例如：

```js
var reg = /[^abc]/g;
var text = 'a1b2c3d4';
var result = text.replace(reg,'X');
console.log(result); //aXbXcXXX
```



## [#](https://cchroot.github.io/interview/pages/interview notes/一篇文章搞定 javascript 正则表达式.html#范围类)范围类

倘若我们需要用字符类匹配数字，按照前面的匹配方式，书写可能会很麻烦，需要这样：'[0123456789]'，对于 a 到 z 的字符更是如此。

为此，正则表达式给我们提供了**范围类**，我们可以使用[a-z]来连接两个字符，表示**从a到z的任意字符**，这是一个闭区间，包含 a 和 z 本身。

```js
var reg = /[a-z]/g;
var text = 'a1b2c3d4z9';
var result = text.replace(reg,'Q');
console.log(result); //Q1Q2Q3Q4Q9
```



可以发现，这样就方便了许多。

此外，在'[]'组成的类的内部是可以连写的[a-zA-Z]，这样就形成了大写字母小写字母完全匹配:

```js
var reg = /[a-zA-Z]/g;
var text = 'a1b2c3d4z9ASDFHDFH';
var result = text.replace(reg,'Q');
console.log(result); //Q1Q2Q3Q4Q9QQQQQQQQ
```



有些童鞋可能会想，我想连范围类里面的'-'字符也一起匹配了，我们该怎么做？

其实也很简单，例如：

```js
var reg = /[0-9]/g; //这样是跟前面一样的结果，不行
var text = '2018-05-13';
var result = text.replace(reg,'Q');
console.log(result); //QQQQ-QQ-QQ

var reg = /[0-9-]/g; //只要在后面另外加一个‘-’符号就可以了
var text = '2018-05-13';
var result1 = text.replace(reg,'Q');
console.log(result1); //QQQQQQQQQQ
```



## [#](https://cchroot.github.io/interview/pages/interview notes/一篇文章搞定 javascript 正则表达式.html#预定义类及边界)预定义类及边界

### [#](https://cchroot.github.io/interview/pages/interview notes/一篇文章搞定 javascript 正则表达式.html#预定义类)预定义类

正则表达式提供预**预定义类**来匹配常见的字符类，让我们书写更方便。

| 字符 |     等价类      |               含义               |
| :--: | :-------------: | :------------------------------: |
|  .   |     [^\r\n]     | 除了回车符和换行符之外的所有字符 |
|  \d  |      [0-9]      |             数字字符             |
|  \D  |     [^0-9]      |            非数字字符            |
|  \s  | [\t\n\x0B\f\r]  |              空白符              |
|  \S  | [^\t\n\x0B\f\r] |             非空白符             |
|  \w  |  [a-zA-Z_0-9]   |  单词字符（字母、数字、下划线）  |
|  \W  |  [^a-zA-Z_0-9]  |            非单词字符            |

digit 数字 '\d'， space空白 '\s'，word字母 '\w',大写取反，妈妈再也不用担心我记错了

来看一个实际的例子，匹配一个 **ab+数字+任意字符** 的字符串：

```js
var reg = /ab\d./; //之前我们可能会这样写：ab[0-9][^\r\n]
var text = 'absdlkjflab91323';
var result = text.replace(reg,'AAAA');
console.log(result); //absdlkjflAAAA323
```



### [#](https://cchroot.github.io/interview/pages/interview notes/一篇文章搞定 javascript 正则表达式.html#边界)边界

除了预定义类，正则表达式还提供了几个常用的边界字符。

| 字符 |   等价类   |
| :--: | :--------: |
|  ^   | 以xxx开始  |
|  $   | 以xxx结束  |
|  \b  |  单词边界  |
|  \B  | 非单词边界 |

我们在第一个例子中用到过'\b'单词边界，这里我们做一个跟上面第一个例子相反的，只把'This'中的'is'替换为'IS'

```js
var reg = /\Bis\b/g;
var text = 'He is a boy, This is a dog. Where is she?';
var result = text.replace(reg,'IS');
console.log(result) //He is a boy, ThIS is a dog. Where is she?
```



然后我们在说一下'^'和'$',在类'[]'中'^'表示取反，但是不在类中的时候'^'表示以xxx开始，'$'表示以xxx结束，这两个边界字符一般放在正则的开始和结束位置。

```js
//先看没加^或$的情况
var reg = /@./g;
var text = '@123@ab@A';
var result = text.replace(reg,'Q');
console.log(result); //Q23QbQ

//添加^的情况
var reg = /^@./g;
var text = '@123@ab@A';
var result1 = text.replace(reg,'Q');
console.log(result1); //Q23@ab@A

//添加$的情况
var reg = /@.$/g;
var text = '@123@ab@A';
var result1 = text.replace(reg,'Q');
console.log(result1); //@123@abQ
```



上面的例子，如果'^'和'$'都加上的话，是匹配不成功的，因为没有符号的字符串可以匹配成功，童鞋们可以自己试试。

这里再结合多行匹配举一个例子：

```js
var reg = /^@\d./g;
var text= '@123\n@456\n@789';
var result = text.replace(reg,'Q');
console.log(result);// Q3  @456  @789
```



这里你会发现，并没有像我们预期的把三行中符合预期的字符都替换成功，只有第一行成功匹配替换了，这是为什么呢？

这是因为，换行符在我们看来是换了一行写而已，但是对于程序处理字符串的时候，换行符就是一个普通的字符，并不算是我们认为的新的一行。这时候我们的修饰符'm'就可以大展身手了：

```js
var reg = /^@\d./gm;
var text= '@123\n@456\n@789';
var result = text.replace(reg,'Q');
console.log(result);// Q3  @6  @9
```



## [#](https://cchroot.github.io/interview/pages/interview notes/一篇文章搞定 javascript 正则表达式.html#量词)量词

倘若我们希望匹配一个连续出现20次的数字的字符串，通过我们之前学习的知识，我们可能会写出连续20个'\d'。假如20次你还可以接受，那100次，1000次，甚至更多次，你怎么办？

为了解决这个问题，正则表达式引入了**量词**的概念，下面是一些量词和他们的含义：

| 字符  |               含义               |
| :---: | :------------------------------: |
|  ？   |  出现零次或一次（最多出现一次）  |
|   +   | 出现一次或者多次（至少出现一次） |
|   *   |    出现零次或者多次（任意次）    |
|  {n}  |             出现n次              |
| {n,m} |            出现n到m次            |
| {n,}  |           至少出现n次            |

我们可以拿文章开始的日期正则举个栗子：

```js
var reg = /\d{4}[/-]\d{2}[/-]\d{2}/g;
var text = '2018-02-23，2018/02/24，2018~02/25';
var result = text.replace(reg,'匹配正确日期格式');
console.log(result);//匹配正确日期格式，匹配正确日期格式，2018~02/25
```



## [#](https://cchroot.github.io/interview/pages/interview notes/一篇文章搞定 javascript 正则表达式.html#贪婪模式)贪婪模式

正则表达式默认是贪婪模式，即每次匹配都尽可能的匹配多的字符，直到匹配失败为止。

举个栗子：

```js
var reg = /\d{3,6}/g;
var text = '12345678';
var result = text.replace(reg,'X');
console.log(result);//X78
```



从上面可以看出，正则表达式匹配了'123456'，而不是'123','1234','12345'，尽可能多的匹配了6次，即贪婪模式。

倘若我们希望它只匹配3次，即尽可能少的匹配，一旦匹配成功不再继续尝试，即非贪婪模式需要怎么做呢？

很简单，在量词后面加上'?'即可,我们再用刚才的例子试一下：

```js
var reg = /\d{3,6}?/g;
var text = '12345678';
var result = text.replace(reg,'X');
console.log(result);//XX78
```



## [#](https://cchroot.github.io/interview/pages/interview notes/一篇文章搞定 javascript 正则表达式.html#分组)分组

假如我们有这么一个场景：匹配字符串 Byron 连续出现3次的场景，根据前面所学，我们可能会这样写：`Byron{3}`。

但是这样是错误的，试试你会发现只有Byronnn才能匹配成功，即最后的n重复了3次，并不能匹配整个单词重复三次的情况：

```js
var reg = /Byron{3}/g;
var text = 'ByronByronByronnn';
var result = text.replace(reg,'0');
console.log(result);//ByronByron0
```



那么，我们要怎么匹配Byron连续出现3次的情况呢，这时候，正则表达式的分组'()'就帮我们解决了这个问题：

```js
var reg = /(Byron){3}/g;
var text = 'ByronByronByronnn';
var result = text.replace(reg,'0');
console.log(result);//0nn
```



### [#](https://cchroot.github.io/interview/pages/interview notes/一篇文章搞定 javascript 正则表达式.html#或)或

有时候，我们可能会需要在匹配时用到或者的关系，利用之前的'[]'字符类（字符集合）可能只能匹配单个字符的或者关系，比如匹配a或b，你可以这样写：'[ab]'，但是如果你需要匹配的是一整个单词的或者关系呢，可能'[]'就不好使了。这时候，我们用'|'可以达到或的效果：

```js
//匹配单词Byron或者Casper
var reg = /Byron|Casper/g;
var text = 'ByronCasper'
var result = text.replace(reg,'X');
console.log(result);//XX

//匹配Byr+on或Ca+sper
var reg = /Byr(on|Ca)sper/g;
var text = 'ByronsperByrCasper'
var result1 = text.replace(reg,'X');
console.log(result1);//XX
```



### [#](https://cchroot.github.io/interview/pages/interview notes/一篇文章搞定 javascript 正则表达式.html#反向引用)反向引用

假如我们有这样一个需求：把日期'2015-12-25'替换成'12/25/2015',如果是你，你现在会怎么做呢？

你可能会这样写：

```js
var reg = /\d{4}-\d{2}-\d{2}/g;
var text = '2015-12-25'
var result = text.replace(reg,'12/25/2015');
console.log(result);//12/25/2015
```



但是上面这样的写法，你只能够匹配到'2015-12-25'了，不能再匹配别的日期了，'2015-12-25'是会变的，这样就达不到需求了。

这时候，正则的**反向引用**就可以取到作用了。表达式在匹配时，表达式引擎会将小括号 "( )" 包含的表达式所匹配到的字符串记录（分组捕获）下来。在获取匹配结果的时候，小括号包含的表达式所匹配到的字符串可以单独获取。

在js中正则匹配成功的字符串可以用$1表示第一次匹配成功，$3表示第三次匹配成功的字符，以此类推至$99）。于是，上面的例子就可以这样写了：

```js
var reg = /(\d{4})-(\d{2})-(\d{2})/g;
var text = '2015-12-25'
var result = text.replace(reg,'$2/$3/$1');
console.log(result);//12/25/2015
```



### [#](https://cchroot.github.io/interview/pages/interview notes/一篇文章搞定 javascript 正则表达式.html#忽略分组)忽略分组

在上面的反向引用中，我们默认是根据'()'全部捕获记录为$1~$99的，倘若我们想忽略某个捕获要怎么办呢？

不希望捕获某些分组，只需要在分组内加上'?:'就可以了。

```js
var reg = /(?:Byron)(\d{4})-(\d{2})-(\d{2})/g;
var text = 'Byron2016-12-05'
var result = text.replace(reg,'$2/$3/$1');
console.log(result);//12/05/2016
```



这时候的$1不是Byron，而是2016了。

## [#](https://cchroot.github.io/interview/pages/interview notes/一篇文章搞定 javascript 正则表达式.html#前瞻)前瞻

正则表达式从文本头部向尾部开始解析，文本尾部方向称为“前”，**前瞻**就是在正则表达式匹配到规则的时候，向前检查是否符合断言，后顾/后瞻方向相反。

符合和不符合断言称为**肯定/正向**匹配和**否定/负向**匹配。

上面是前瞻的概念，是不是看完有点晕？我看完也有点晕...我来解释一下：假如你需要匹配一个名字叫“张三”的人，以前我们可能是从一堆人中找出名字是“张三”的揪出来就行了，但是前瞻就是要求你，揪出的人的名字叫“张三”还不够，还必须“张三”的父亲必须叫“张二”或者其它特定条件，这样就是前瞻了，类似的，后瞻就是名字是张三还不够，儿子还必须叫“小张”等。

是不是有点明白了？不过需要注意的是，**在javascript中是不支持后顾/后瞻**的，所以我们也不需要关心了。(这里纠正一下，在 ES2018(ES9) 中已经支持后瞻和命名分组了)

至于符合/不符合断言，可以解释为：比如匹配要求名字叫“张三”，并且呢他父亲不叫“张二”，对于符合的我们就叫正向/肯定匹配，不符合的就叫负向/否定匹配。

我们再用表格说明一下：

|   名称   |      正则      |                             含义                             |
| :------: | :------------: | :----------------------------------------------------------: |
| 正向前瞻 | exp(?=assert)  | 我们匹配符合了exp部分的表达式，然后还不算完，必须也匹配断言部分（'()'内部，'='后面的正则），才算成功 |
| 负向前瞻 | exp(?!assert)  | 我们匹配符合了exp部分的表达式，然后还不算完，必须也匹配断言部分（'()'内部，'！'后面的正则），才算成功 |
| 正向后顾 | exp(?<=assert) |                       javascript不支持                       |
| 负向后顾 | exp(?<!assert) |                       javascript不支持                       |

现在是不是清楚了？如果还不够明白，没事，我们再举个栗子：

```js
var reg = /\w(?=\d)/g;
var text = 'a2*3';
var result = text.replace(reg,'X');
console.log(result);//X2*3
```



需要注意，我们**断言**里面内容只是作为匹配的条件之一，也是必须的条件，但是匹配的本质只匹配"()"前面的正则，所以上面的结果为：'X2*3',而不是'X*3'。如果要匹配结果为后者，我们按原来的写法就行了`var reg = /\w\d/g;`，不是吗?

## [#](https://cchroot.github.io/interview/pages/interview notes/一篇文章搞定 javascript 正则表达式.html#对象属性)对象属性

我们在用正则表达式相关的方法时，经常会用到正则表达式相关的一些对象属性，下面我们总结一下正则表达式相关的对象属性：

- golbal: 是否全文搜索，默认false
- ignore case: 是否大小写敏感，默认false
- multiline: 多行搜索，默认false
- lastIndex: 是当前表达式匹配内容的最后一个字符的下一个位置
- source: 正则表达式的文本字符串

其中前面三个我们在上文中已经提到过了，source的话，我们一起结合起来看看代码：

```js
var reg1 = /\w/;
var reg2 = /\w/gim;

console.log(reg1.global);//false
console.log(reg1.ignoreCase);//false
console.log(reg1.multiline);//false

console.log(reg2.global);//true
console.log(reg2.ignoreCase);//true
console.log(reg2.multiline);//true

console.log(reg1.source);//\w
console.log(reg2.source);//\w
```



golbal、ignore case、multiline默认都是false,而source就是你写的正则字符串文本了。

至于lastIndex，我们先来看一个例子：

```js
var reg1 = /\w/;
var reg2 = /\w/g;

console.log(reg1.test('a'));//true
console.log(reg1.test('a'));//true
console.log(reg1.test('a'));//true
//... 不管执行多少次都是true

console.log(reg2.test('ab'));//true
console.log(reg2.test('ab'));//true
console.log(reg2.test('ab'));//false
console.log(reg2.test('ab'));//true
console.log(reg2.test('ab'));//true
console.log(reg2.test('ab'));//false
//... 循环true true false
```



对于上面的结果，是不是很奇怪？这就是'lastIndex'作用的结果了，（至于test方法，不懂的童鞋可以往下翻一番）。我们来输出'lastIndex'试试:

```js
var reg2 = /\w/g;
while(reg2.test('ab')){
  console.log(reg2.lastIndex); // 1   2
}
```



可以发现，'lastIndex'是在不断发生变化的，即当前匹配结果的最后一个字符的下一个位置，这里第一次匹配到'a'字符，匹配结果的最后一位字符也是'a','a'字符的下一个位置的index就是1了。类似的第二次匹配'b'，匹配结果的最后一位字符也是'b','b'字符的下一个位置的index就是2。现在再看看概念，是不是明白了许多？

所以说，正则每次匹配并不是从头开始的，而是从上次的结果往后找，看看后面还有没有，有的话继续匹配，当然这必须是在'g'全局匹配的基础上，不然每次匹配都是从头开始的。

## [#](https://cchroot.github.io/interview/pages/interview notes/一篇文章搞定 javascript 正则表达式.html#正则表达式regexp对象本身的方法)正则表达式RegExp对象本身的方法

RegExp对象自带的方法总共有三个：

1. test： 检索字符串中指定的值。返回 true 或 false
2. exec： 检索字符串中指定的值。返回找到的值，并确定其位置
3. compile： 编译正则表达式（不常用）

### [#](https://cchroot.github.io/interview/pages/interview notes/一篇文章搞定 javascript 正则表达式.html#test方法)test方法

test() 方法用于测试字符串参数中是否存在匹配正则表达式模式的字符串，如果存在则返回 true ,否则返回 false 。

语法为`RegExpObject.test(string)`，如果字符串 string 中含有与 RegExpObject 匹配的文本，则返回 true，否则返回 false。

举个栗子:

```js
var str = "good good study, day day up";
var reg = new RegExp("study");
var result = reg.test(str);
console.log(result);//true
```



### [#](https://cchroot.github.io/interview/pages/interview notes/一篇文章搞定 javascript 正则表达式.html#exec方法)exec方法

exec() 方法用于使用正则表达式模式对字符串执行搜索，并将更新全局 RegExp 对象的属性以反映匹配结果。

语法为`RegExpObject.exec(string)`,如果字符串 string 中含有与 RegExpObject 匹配的文本,则返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。

并且，数组存在两个额外的属性：

1. index: 声明匹配文本的第一个字符的位置
2. input: 存放被检索的字符串 String

exec()方法比较复杂，全局调用和非全局调用的结果不同：

**非全局（即不带'g'）调用**：

- 调用非全局的 RegExp 对象的exec()时，返回数组
- 数组中第一个元素是正则表达式匹配的文本
- 数组中第二个元素是与 RegExpObject 的第一个子表达式相匹配的文本（如果有的话）
- 数组中第三个元素是与 RegExp 对象的第二个子表达式相匹配的文本（如果有的话，以此类推

看起来是不是又有点晕？不怕，我们来看看例子：

```js
var reg3 = /\d(\w)\d/;
var str = '1a2b3c4d5e';
var arr = reg3.exec(str);
console.log(reg3.lastIndex + '\t' + arr.index + '\t' + arr.toString());//0	0	1a2,a
```



即输出结果为： lastIndex(这里为0是因为非全局匹配下lastIndex其实是不生效的),匹配文本的第一个字符的位置(额外属性index,这里第一个字符为'1')和匹配结果数组('1a2'为匹配文本，'a'为子表达式'(\w)'的匹配结果，这里不存在第二个子表达式'()'，所以数组里面没有第三个匹配结果的值)。是不是清楚了许多？

**全局调用**：

- exec() 会在 RegExpObject 的 lastIndex 属性指定的字符处开始检索字符串 string。
- 当 exec() 找到了与表达式相匹配的文本时，在匹配后，它将把 RegExpObject 的 lastIndex 属性设置为匹配文本的最后一个字符的下一个位置。
- 这就是说，你可以通过反复调用 exec() 方法来遍历字符串中的所有匹配文本。
- 当 exec() 再也找不到匹配的文本时，它将返回 null，并把 lastIndex 属性重置为 0。
- 注意：如果在一个字符串中完成了一次模式匹配之后要开始检索新的字符串，就必须手动地把 lastIndex 属性重置为 0。

我们同样来举个栗子：

```js
var reg4 = /\d(\w)(\w)\d/g;
var str = '$1az2bb3cy4dd5ee';

while(arr = reg4.exec(str)){
  console.log(reg4.lastIndex + '\t' + arr.index + '\t' + arr.toString());
  //5    1   1az2,a,z
  //11   7   3cy4,c,y
}
```



这里我就不在解释结果的含义了，相信童鞋们看完上面的非全局的解释就可以理解这里全局的情况了。

### [#](https://cchroot.github.io/interview/pages/interview notes/一篇文章搞定 javascript 正则表达式.html#compile方法)compile方法

compile() 方法用于在脚本执行过程中编译正则表达式，也可用于改变和重新编译正则表达式。这个我们在平时工作中一般不会用到（我至今没看到过...）;

它的语法为：`RegExpObject.compile(regexp,modifier)`，其中参数'regexp'为正则表达式，参数'modifier'为规定匹配的类型。"g" 用于全局匹配，"i" 用于区分大小写，"gi" 用于全局区分大小写的匹配（摘录于W3C）。

我们来看一个例子：

```js
var str = "Every man in the world! Every woman on earth!";
var reg = /man/g;
var str2 = str.replace(reg,"person");
console.log(str2)

var reg2=/(wo)?man/g;
reg.compile(reg2);
console.log(reg.source);//(wo)?man  这里可以看到reg通过compile编译为reg2一样了
var str2=str.replace(reg,"person");
console.log(str2);
```



上面的意思就是：在字符串中全局搜索 "man"，并用 "person" 替换。然后通过 compile() 方法，改变正则表达式reg为reg2，并继续利用正则改变后的正则表达式reg，用 "person" 替换 "man" 或 "woman"。

至于为什么用compile动态改正则，那跟新建有啥区别呢？

我查了查资料是这么说的：如果指定的正则表达式需要多次重复使用，那么编译正则表达式将会提高代码的执行效率，不过如果仅仅执行一次或者少数几次，那么将不会有明显的效果，compile提高了正则表达式的适应性！

## [#](https://cchroot.github.io/interview/pages/interview notes/一篇文章搞定 javascript 正则表达式.html#支持正则表达式的-string-对象的方法)支持正则表达式的 String 对象的方法

支持正则表达式的 String 对象的方法有：

- search： 检索与正则表达式相匹配的值
- match： 找到一个或多个正则表达式的匹配。
- replace： 替换与正则表达式匹配的子串。
- split： 把字符串分割为字符串数组。

### [#](https://cchroot.github.io/interview/pages/interview notes/一篇文章搞定 javascript 正则表达式.html#search)search

search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式匹配的子字符串

语法为`stringObject.search(regexp)`,结果返回 stringObject 中第一个与 regexp 相匹配的子串的起始位置index，如果没有找到任何匹配的子串，则返回 -1。

需要注意的是，search() 方法不执行全局匹配，它将忽略修饰符'g',并且总是从字符串的开始进行检索。

来看一个例子：

```js
var str = 'a1b2c3d4';
console.log(str.search('1')); //1
console.log(str.search('10')); //-1
console.log(str.search(/b2/)); //2
console.log(str.search(/\w\d/g)); //0
console.log(str.search(/\w\d/g)); //0 忽略'g',执行多次未返回不同结果
```



### [#](https://cchroot.github.io/interview/pages/interview notes/一篇文章搞定 javascript 正则表达式.html#match)match

match() 方法将检索字符串，以找到一个或多个与 RegExp 匹配的文本，在 RegExp 是否有修饰符'g'影响很大。该方法类似 indexOf() 和 lastIndexOf()，但是它返回指定的值，而不是字符串的位置。

语法为`stringObject.match(searchvalue)或stringObject.match(regexp)`，结果返回存放匹配结果的数组。该数组的内容依赖于 regexp 是否具有全局标志 g。

match() 方法也分全局调用和非全局调用：

**非全局调用**

- 如果 regexp 没有标志 g ，那么 match() 方法就只能在字符串中执行匹配一次
- 如果没有找到任何匹配文本，返回 null
- 否则它将返回一个数组，其中存放了与它找到的匹配文本有关的信息：
- 数组的第 0 个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本。（这里与前面说的exec()方法类似）

并且，数组也存在两个额外的属性（与 exec() 方法基本相同）：

1. index: 声明匹配文本的第一个字符的位置
2. input: 声明对 stringObject 的引用

下面是举例：

```js
var reg3 = /\d(\w)\d/;
var str = '1a2b3c4d5e';
var arr = str.match(reg3);
console.log(reg3.lastIndex + '\t' + arr.index + '\t' + arr.toString());//0  0  1a2,a
```



可以看到结果都与 exec() 方法一样，只是字符串和正则的位置交换了一下。

**全局调用**

全局调用就和 exec() 不同了：

- 如果 regexp 具有标志 g 则 match() 方法将执行全局检索，找到字符串中所有匹配的子字符串
- 没有找到任何匹配的子字符串则返回 null
- 如果找到了一个或者多个匹配字串，则返回一个数组
- 数组元素中存放的是字符串中所有匹配的字串，而且也没有index属性和input属性

简单的说，就是返回一个数组，数组中放着所有匹配结果。

```js
var reg4 = /\d(\w)(\w)\d/g;
var str = '$1az2bb3cy4dd5ee';
var arr = str.match(reg4)
console.log(arr); // ["1az2", "3cy4"]
console.log(reg4.lastIndex + '\t' + arr.index) //0	undefined
```



可以看出，match() 方法功能没有 exec() 方法返回那么多各种信息，但是如果只要结果数组，match() 方法效率会高一些。

### [#](https://cchroot.github.io/interview/pages/interview notes/一篇文章搞定 javascript 正则表达式.html#split)split

对于split()方法我就不详细说明了，我们经常用它把字符串分割为数组。

```js
var str = 'a,b,c,d';
var arr = str.split(',');
console.log(arr); //['a','b','c','d']
```



但是你可能不知道，我们在一些复杂情况下我们可以使用正则表达式解决

```js
var str = 'a1b2c3d';
var arr = str.split(/\d/);
console.log(arr); //['a','b','c','d']
```



上面可能还看不出 spilt() 方法用正则分割的有点，但是如果复杂一点的分割呢，比如：

```js
var str = 'a1b&c|d&e';
var arr = str.split(/[\d|&]/);
console.log(arr); //['a','b','c','d','e']
```



这样是不是看出了用正则的优势呢？

小知识：其实，我们在用 split() 分割字符','的时候，split() 方法也是把',' 隐士转换成正则'/,/'的, search() 方法和 replace() 方法也是一样的。

### [#](https://cchroot.github.io/interview/pages/interview notes/一篇文章搞定 javascript 正则表达式.html#replace)replace

replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。

语法为`stringObject.replace(regexp/substr,replacement)`,结果返回一个新的字符串，是用 replacement 替换了 regexp 的第一次匹配或所有匹配之后得到的。

对于 replace() 方法，它有三种使用方式：

1. String.prototype.replace(str,replaceStr);
2. String.prototype.replace(reg,replaceStr);
3. String.prototype.replace(reg,function);

1和2两种的使用我就不再多举例了，相信如果你认真看完前面的文章，肯定最熟悉的就是 replace() 方法了的一、二两种用法了。 这里就提一下第3种使用方法。

先说一下`String.prototype.replace(reg,function);`中 function 的参数含义,function 会在每次匹配替换的时候调用，有四个参数（第二个参数不固定）：

1. 匹配字符串
2. 正则表达式的分组内容，没有分组则没有该参数、
3. 匹配项在字符串中的 index
4. 原字符串

照例来举两个个栗子看看：

```js
var str = 'a1b2c3d4e5';
var reg = /\d/g;
var arr = str.replace(reg,function(match, index, origin){
  console.log(index);// 1 3 5 7 9
  return parseInt(match) + 1;
})
console.log(arr);//a2b3c4d5e6 把每次匹配到的结果+1替换


var str = 'a1b2c3d4e5';
var reg = /(\d)(\w)(\d)/g;
var arr = str.replace(reg,function(match, group1, group2, group3, index, origin){
  console.log(match);// 1b2   3d4
  return group1 + group3;
})
console.log(arr);//a12c34e5  去除了每次匹配到的group2
```



文章到这里就全部结束了,每个例子都是实际测试输出结果,码了好久好久......希望文章对您有帮助，我就心满意足了~~

完~



# [#](https://cchroot.github.io/interview/pages/interview notes/interview.html#很久很久以前的面试复习一)很久很久以前的面试复习一

## [#](https://cchroot.github.io/interview/pages/interview notes/interview.html#杂谈)杂谈

jquery 源码： 核心架构，事件委托，插件机制

项目开发中遇到过什么难题，怎么解决的~

npm 常用命令 webpack

自我陈述准备：把我面试的沟通方向，阔达、自信的适度发挥

简历： 左右和纵向分栏，项目做完之后的公司收益和技术收益，兴趣说技术相关兴趣

遇到不懂的问题，可以说指导，回去思考，好奇，不要说不知道，不懂，没经历过结尾，要资料，再来~

自如谈兴趣，巧妙示实例，适时讨疑问，节奏要适宜，切忌小聪明

## [#](https://cchroot.github.io/interview/pages/interview notes/interview.html#三栏布局)三栏布局

布局：高度已知，左右固定，中间自动：浮动，绝对定位，弹性盒子，display:table-cell,网格布局，然后其各自有什么优缺点，假设高度已知去除会怎么样？如果有一个高度比较高，撑开了，别的跟着撑开（flex和table可以用）？这五种方案的兼容性如何？最优方案是哪个？最后：BFC,圣杯和双飞翼布局，以及felx布局

布局小结：语义化掌握到位，页面布局理解深刻，CSS基础知识扎实，思维灵活且积极向上，代码规范

布局变通： 三栏布局：左右宽度固定，中间自适应； 上下高度固定，中间自适应。 两栏布局：左宽固定，右自适应； 右宽固定，左自适应； 上高度固定，下自适应；下高度固定，上自适应~

## [#](https://cchroot.github.io/interview/pages/interview notes/interview.html#css盒模型-谈谈你对css盒模型的认识)CSS盒模型：谈谈你对CSS盒模型的认识：

1、 border、margin、padding、content,标准模型和IE模型 2、 标准模型和IE模型的区别 3、 CSS如何设置这两种模型 4、 JS如何设置获取盒模型对应的宽和高: dom.style.width/height--只能获取行内（内联）样式的宽高 dom.currentStyle.width/height--渲染以后的样式，只有IE支持 window.getComputedStyle(dom).width/height--兼容性好，对比第二种 dom.getBoundingClientRect().width/height--常用来计算元素对于视口的位置（top,left,right,bottom,width,height） 5、 根据盒模型解释边距重叠 6、 BFC边距重叠解决方案

BFC的基本概念：块级格式化上下文，它是指一个独立的块级渲染区域，只有Block-level BOX参与，该区域拥有一套渲染规则来约束块级盒子的布局，且与区域外部无关。

BFC的生成：CSS2.1中规定满足下列CSS声明之一的元素便会生成BFC：

- 根元素（html本身就是BFC）
- float的值不为none
- overflow的值不为visible
- display的值为inline-block、table-cell、table-caption
- position的值为absolute或fixed

BFC的约束规则（原理）：

1. 内部的Box会在垂直方向上一个接一个的放置
2. 垂直方向上的距离由margin决定。（完整的说法是：属于同一个BFC的两个相邻Box的margin会发生重叠，与方向无关，给子元素再加一个父元素，父元素创建一个BFC即可解决）
3. 每个元素的左外边距与包含块的左边界相接触（从左向右），即使浮动元素也是如此。（这说明BFC中子元素不会超出他的包含块，而position为absolute的元素可以超出他的包含块边界）
4. BFC的区域不会与float的元素区域重叠（一个固定宽度浮动，一个只设高度且创建BFC即可）
5. 计算BFC的高度时，浮动子元素也参与计算（创建BFC清除浮动原理，例如：子元素浮动，父元素overflow:auto）
6. BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素，反之亦然

## [#](https://cchroot.github.io/interview/pages/interview notes/interview.html#dom事件类)DOM事件类

基本概念：DOM事件的级别（例如：DOM2的事件）

- DOM0 element.onclick=function(){}
- DOM2 element.addEventListener('click',function(){},false)
- DOM3 element.addEventListener('keyup',function(){},false)

DOM事件模型（捕获和冒泡）

DOM事件流 (捕获阶段=>目标阶段=>冒泡阶段)

描述DOM事件捕获的具体流程(window->document->html(document.documentElement)->body->...->目标元素)，冒泡相反

Event对象的常见应用

- event.preventDefault()
- event.stopProagation()
- event.stopImmediatePropagation() //同一个元素绑定两个点击事件，可阻止一个事件触发
- event.currentTarget //当前所绑定的事件,测试
- event.target

自定义事件

```js
var eve = new Event('custome');
element.addEventListener('custome',function(){
  console.log('custome')
});
element.dispatchEvent(eve);

//CustomEvent 可以传入obj数据:
var eve2 = new CustomEvent('custome2',obj);
element.addEventListener('custome2',function(){
  console.log('custome')
});
element.dispatchEvent(eve2);
```

1
2
3
4
5
6
7
8
9
10
11
12

## [#](https://cchroot.github.io/interview/pages/interview notes/interview.html#http协议类)HTTP协议类

- HTTP协议的主要特点
  - 简单快速，灵活，无连接，无状态
- HTTP报文的组成部分
  - 请求报文：请求行、请求头、空行、请求体
  - 相应报文：状态行、响应头、空行、响应体
- HTTP方法
  - GET->获取资源
  - POST->传输资源
  - PUT->更新资源
  - DELETE->删除资源
  - HEAD->获得报文首部
  - PATCH->对资源进行部分修改
  - OPTIONS->查询支持的方法
  - CONNECT->要求在与代理服务器通信时建立隧道
  - TRACE->追踪路径
- POST和GET的区别
  - GET在浏览器回退时是无害的，而POST会再次请求
  - GET产生的URL地址可以被收藏，而POST不可以
  - GET请求会被浏览器主动缓存，而POST不会，除非手动设置
  - GET请求只能进行URL编码，而POST支持多种编码方式
  - GET请求参数会被完整保存在浏览器历史纪录里，而POST中的参数不会被保留
  - GET请求在URL中传输的参数是有长度限制的，而POST没有限制
  - 对参数的数据类型，GET只接受ASCLL字符，而POST没有限制
  - GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息
  - GET参数通过URL传递，POST放在Request body中
  - GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。
  - GET产生一个TCP数据包；POST产生两个TCP数据包。
- HTTP状态吗
  - 1XX 指示信息-表示请求已被接收，继续处理
  - 2XX 成功-表示请求已被成功接收并成功进行了处理
  - 3XX 重定向-要完成请求必须进行更进一步的操作
  - 4XX 客户端错误-请求有语法错误或请求无法实现
  - 5XX 服务器错误-服务端未能正常处理客户端的请求而出现意外错误
- 什么是持久连接
  - HTTP协议采用“请求-应答”模式，当使用普通模式，即非Keep-Alive模式时，每个请求/应答客户端和服务器都需要新建一个连接，完成之后立即断开连接（HTTP协议为无连接协议）
  - 当使用Keep-Alive模式（又称持久连接、连接复用）时，Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接
- 什么是管线化
  - 在使用持久连接的情况下，某个连接上的消息传递类似于：请求1->响应1->请求2->响应2->请求3->响应3
  - 某个连接上的消息变成了类似这样：请求1->请求2->请求3->响应1->响应2->响应3
- HTTP缓存

## [#](https://cchroot.github.io/interview/pages/interview notes/interview.html#原型链类)原型链类

- 创建对象有几种方法(3种)
  - var o1 = {name:'o1'};var o11 = new Object({name:'o11'});
  - var M = function(){this.name='o2'};var o2 = new M();
  - var P = {name:'o3'};var o3 = Object.create(P);
- 原型、构造函数、实例、原型链
- instanceof原理
  - 沿着A的_proto_这条线来找，同时沿着B的prototype这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false。
- new运算符
  - 创建一个新空对象
  - 空对象继承（指向）构造函数的prototype原型对象
  - 构造函数被执行，上下文this会被指定到这个新实例对象上
  - 如果构造函数返回了一个“对象”，那么这个对象会取代new出来的对象。如果构造函数没有返回对象，那么new出来的结果为步骤一创建的新对象。

```js
//new运行原理
var new2 = function(func){
  var o = Object.create(func.prototype); //创建空对象，空对象关联构造函数的原型链
  var k = func.call(o); //执行构造函数
  if(typeof k === 'object'){ //判断结果是不是对象类型
    return k;
  }else{
	return o;
  }
}
```

1
2
3
4
5
6
7
8
9
10

```js
//通过原型继承创建一个新对象
function inherit(proto){
  if(proto == null) {throw TypeError()};
  if(Object.create()) return Object.create(proto);
  var t = typeof(proto);
  if(t ！== 'object' && t !== 'function') throw TypeError();
  var F = function(){};
  F.prototype = proto;
  return new F();
}
```

1
2
3
4
5
6
7
8
9
10

## [#](https://cchroot.github.io/interview/pages/interview notes/interview.html#面向对象类)面向对象类

### [#](https://cchroot.github.io/interview/pages/interview notes/interview.html#类与实例)类与实例

- 类的声明
- 生成实例

```js
//构造函数的方式继承
function Animal(){
  this.name = 'name';
}

//ES6的方式
class Animal2{
  constructor(){
	this.name = 'name';
  }
}

//实例化,声明方式不一样，但是实例化方式是一样的
console.log(new Animal(),new Animal2())
```

1
2
3
4
5
6
7
8
9
10
11
12
13
14

### [#](https://cchroot.github.io/interview/pages/interview notes/interview.html#类与继承)类与继承

- 如何实现继承
- 继承的几种方式

```js
//借助构造函数实现继承
function Parent1(){
  this.name = 'parent1'
}
function Child1(){
  //在子类中执行需继承的构造函数
  //这样就改变了Parent1()的this指向
  //从而导致了父类执行的属性都会挂载到子类的实例上去
  Parent1.call(this);
  this.type = 'child1'
}
console.log(new Child1)//没有参数可以不写小括号
//缺点:Parent1原型链上的方法没有办法被继承，只实现了部分继承
//无法实现函数复用，每个子类都有父类实例函数的副本，影响性能
```

1
2
3
4
5
6
7
8
9
10
11
12
13
14

```js
//借助原型链继承
function Parent2(){
  this.name = 'parent2';
}
function Child2(){
  this.type = 'child2'
}
//让构造函数的实例能访问到父类的原型对象上的属性和方法
//Parent2的实例赋值给 Child2.prototype 属性
//new Child2().__proto__ => Child2.prototype == new Parent2() 
Child2.prototype =  new Parent2();
console.log(new Child2())

//缺点:来自原型对象的引用属性是所有实例共享的,child1.__proto__==child2.__proto__
//无法实现多继承
//创建子类实例时，无法向父类构造函数传参
//要想为子类新增属性和方法，必须要在new Animal()这样的语句之后执行，不能放到构造器中
```

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17

```js
//组合继承
function Parent3(){
  this.name = 'parent3';
  this.paly = [1,2,3];
}
function Child3(){
  Parent3.call(this);
  this.tpye = 'child3'
}
Child3.prototype = new Parent3();
var s3 = new Child3();
var s4 = new Child3();
s3.paly.push(4);
console.log(s3.play,s4.paly);
//缺点:父级构造函数实例化了两次~
```

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15

```js
//组合继承优化1
function Parent4(){
  this.name = 'parent4';
  this.paly = [1,2,3];
}
function Child4(){
  Parent4.call(this);
  this.tpye = 'child4'
}
Child4.prototype = Parent4.prototype; //引用同一个对象,导致constructor相同
var s5 = new Child4();
var s6 = new Child4();
s3.paly.push(4);
console.log(s5.play,s6.paly);
console.log(s5 instanceof Child4,es5 instanceof Parent4)//true true //无法区分是父类(Parent4)还是子类(Child4)实例化的
console.log(s5.constructor) //Parent4 引用导致，这不是我们想要的
```

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16

```js
//组合继承优化2
function Parent5(){
  this.name = 'parent5';
  this.paly = [1,2,3];
}
function Child5(){
  Parent5.call(this);
  this.tpye = 'child5'
}
Child5.prototype = Object.create(Parent5.prototype);
//Object.create原理：创建空对象，空对象关联构造函数(Parent5)的原型链
child5.prototype.constructor = Child5; //还是需要指定constructor
var S7 = new Child5();
console.log(s7 instanceof Child5,s7 instanceof Parent5)//true true
console.log(s7.constructor) // Child5
```

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15

- 其它继承方式：

```js
//实例继承
function Parent6(){
  this.name = 'parent2';
}
function Child6(name){
  var parent = new Parent6();
  parent.name = name || 'Tom';
  return parent;
}
//实例是父类的实例，不是子类的实例
//无法实现多继承
```

1
2
3
4
5
6
7
8
9
10
11

```js
//拷贝继承
function Parent7(){
  this.name = 'parent7';
}
function Child7(name){
  var parent = new Parent7();
  for(var p in parent){
    Child6.prototype[p] = parent[p];
  }
  Cat.prototype.name = name || 'Tom';
}
//效率较低，内存占用高
//无法获取父类不可枚举的方法
```

1
2
3
4
5
6
7
8
9
10
11
12
13

## [#](https://cchroot.github.io/interview/pages/interview notes/interview.html#通讯类)通讯类

- 什么是同源策略及限制
  - 同源策略限制从一个源加载的文档如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键安全机制。(http协议，域名，端口)
  - 主要限制在：cookie，localStrage和IndexedDB无法读取；DOM无法获得，Ajax无法发送
- 前后端如何通讯
  - ajax,websocket,CORS,EventSource,服务端渲染
- 如何创建Ajax
  - XMLHttpRequest对象的工作流程
  - 兼容性处理（IE）
  - 事件的触发条件
  - 事件的触发顺序
- 跨域通讯的几种方式
  - JSONP
  - Hash
  - postMessage
  - websocket
  - CORS
  - window.name
  - window.domain

## [#](https://cchroot.github.io/interview/pages/interview notes/interview.html#安全类)安全类

- CSRF 跨站请求伪造
  - 基本概念和缩写
    - cross-site request forgery
  - 攻击原理
    - 登陆过A网站
    - 在访问B网站时，B网站诱使点击连接访问A网站(通过对A网站还存在的cookie等身份验证)
  - 防御措施
    - Token验证， 访问接口时候带token
    - Referer验证 页面来源，同域
    - 隐藏令牌 类似于token,例如隐藏在头部
    - 输入验证码
- XSS 跨域脚本攻击
  - 基本概念和缩写
    - cross-site scripting
  - 攻击原理
    - 向页面注入脚本运行，脚本中做攻击内容，通过input，textarea等标签，例如输入评论内容的时候
    - 危害：窃取用户的 Cookie 值;伪造虚假的输入表单骗取个人信息;显示伪造的文章或者图片
  - 防御措施
    - 过滤标签符号'< >'等
    - 设置 Cookie 为 HttpOnly
- SQL注入
  - 基本概念
    - 服务器上的数据库运行非法的 SQL 语句，主要通过拼接来完成。
  - 攻击原理
    - 在搜索或查询等SQL查询时，拼接非法SQL查询隐藏数据或者本不可以显示的内容等
  - 防范手段
    - 使用参数化查询
    - 单引号转换
- DOS 拒绝服务攻击
  - 原理
    - 其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。

## [#](https://cchroot.github.io/interview/pages/interview notes/interview.html#算法类)算法类

- 排序
  - 快速排序 https://segmentfault.com/a/1190000009426421
  - 选择排序 https://segmentfault.com/a/1190000009366805
  - 希尔排序 https://segmentfault.com/a/1190000009461832
- 堆栈、队列、链表 https://juejin.im/entry/58759e79128fe1006b48cdfd
- 递归 https://segmentfault.com/a/1190000009857470
- 波兰式和逆波兰式
  - http://www.cnblogs.com/chenying99/p/3675876.html
  - https://github.com/Tairraos/rnp.js/blob/master/rpn.js

技巧：

- 伪代码
- 找面试官要提示
- 用了什么算法，原理

## [#](https://cchroot.github.io/interview/pages/interview notes/interview.html#渲染机制)渲染机制

- 什么是DOCTYOE及作用
  - DTD文档类型定义，用来定义XML或者(X)HTML的文件类型。浏览器使用它来判断文档类型，决定使用何种协议来解析，以及切换浏览器模式。
  - DOCTYOE是用来声明文档类型和DTD规范的，一个主要用途就是验证文件的合法性。
  - HTML5 <!DOCTYPE html>
  - HTML 4.01 Strict
  - HTML 4.01 Transitional
- 浏览器渲染过程 ![这里写图片描述](imgs/11_其它/browser.png)
- 重排Reflow
  - DOM结构中的各个元素都有自己的盒子（模型），这些都需要浏览器根据各种样式来计算并根据计算结果将元素放到它该出现的位置，这个过程称为reflow
- 重绘Repaint
  - 当盒子的位置、大小及其他属性都确认后，浏览器于是便把这些元素都照各自的特性绘制了一遍，于是页面的内容出现了，这个过程为repaint
- 布局Layout

## [#](https://cchroot.github.io/interview/pages/interview notes/interview.html#js运行机制)js运行机制

- 理解JS的单线程的概念
- 理解任务队列
- 理解Event Loop
- 理解哪些语句会放入异步任务队列
  - setTimeout和setInterval
  - DOM事件
  - ES6中的Promise
- 理解语句放入异步任务队列的时机
  - 时间计算到了才放入异步队列

## [#](https://cchroot.github.io/interview/pages/interview notes/interview.html#页面性能类)页面性能类

提升页面性能的方法有哪些?

1. 资源压缩合并，减少HTTP请求
2. 非核心代码异步加载->异步加载的方式->异步加载的区别
   - 异步加载的方式：1、动态脚本加载；2、defer；3、async
   - 异步加载的区别：1、defer是在HTML解析完以及同步js执行完之后才会执行，如果是多个，安装加载的顺序依次执行；2、async是在加载完成之后立即执行，如果是多个，执行顺序和加载顺序无关。
3. 利用浏览器缓存->缓存的分类->缓存的原理
   - 强缓存：Expires （Expires:Thu,21 Jan 2017 23：39：02） GMT；Cache-Control (Cache-Control:max-age=3600)
   - 协商缓存：Last-Modified If-Modified-Since Etag If-None-Match (Last-Modified:Web,26 Jan 2017 00:35:11 GMT)
   - Expires是绝对时间，取客户端电脑的时间来对比，可能不准确，而且可能被修改，Cache-Control是相对时间
   - Last-Modified 与 If-Modified-Since的值相同，Last-Modified是服务器下发的时间，If-Modified-Since是客户端触发协商缓存，请求询问服务器带入的请求头中。这个方式的协商缓存有一个缺点，有可能文件改动了，但是内容没变，所有才有了Etag
   - Etag是服务器下发的key值（Hash值），If-None-Match是客户端触发协商缓存，请求询问服务器key值(内容)有没有变化，是否可以使用缓存。
4. 使用CDN（3~4个域名cdn，并行加载）
5. 预解析DNS
   - `<meta http-equiv="x-dns-prefetch-control" content="on"> //强制打开dns预解析，a标签默认开启，但是https情况下是一般是关闭的`
   - `<link ref="dns-prefetch" href="XXX">`

优化分类：

- 网络层面
- 构建层面
- 浏览器渲染层面
- 服务端层面

优化方式：

- 资源的合并与压缩
  - 压缩 html,css,js
  - 资源合并：公共库合并，业务分离，不同页面的合并，见机行事，随机应变
- 图片编解码和类型选择
  - 不同场景选择不同格式图片
  - 雪碧图大小要合适，同页面的图片，并且小于一定大小的合并
- 浏览器的渲染机制
  - 顺序执行、并发加载，域名并发限制（3~4个cdn域名并发加载）
  - 是否阻塞
  - 依赖关系
  - 引入方式（css阻塞js的运行，但是不阻止js加载）
  - 重绘与回流，图层（将频繁重绘回流的 DOM 元素单独作为一个图层，但是图层也不能过多）
  - 创建图层的方式：
    - 3D 或透视变换 css 属性
    - 使用加速视频解码的 video 节点
    - 拥有 3D（webGL）上下文或加速的2D 上下文 canvas 节点
    - 混合插件（如Flash）
    - 对自己的 opacity 做 CSS 动画或使用一个动画 webkit 变换的元素
    - 拥有 css 过滤器的元素
    - 元素有一个包含复合层的后代节点
    - 元素有一个 z-index 较低且包含一个符合层的兄弟元素
- 懒加载预加载
- 浏览器存储
- 缓存机制
- PWA
- Vue-SSR

请求过程中潜在的性能优化点（理解http请求过程是核心）：

- dns 是否可以通过缓存减少 dns 查询时间？
- 网络请求的过程走最近的网络环境？
- 相同的静态资源是否可以缓存？
- 能否减少 http 请求的大小？
- 减少 http 请求
- 服务端渲染

## [#](https://cchroot.github.io/interview/pages/interview notes/interview.html#错误监控)错误监控

- 前端错误的分类
  - 即时运行错误：代码错误
  - 资源加载错误
- 错误的捕获方式
  - 即时运行错误：try...catch 和 window.onerror
  - 资源加载错误：object.onerror（在节点上绑定onerror,该错误不会冒泡）、performance.getEntries()和Error事件捕获（window.addEventListener('error',function(e){console.log('捕获',e)},true)）

延伸：跨域的JS运行错误可以捕获吗？错误提示是什么？怎么处理？

1. 在script标签增加crossorigin属性
2. 设置JS资源响应投Access-Control-Allow-Origin:*

- 上报错误的基本原理
  - 采用Ajax通信的方式上报
  - 利用Image对象上报(new Image()).src='接口地址'

## [#](https://cchroot.github.io/interview/pages/interview notes/interview.html#业务能力)业务能力

- 准备要充分
  - 项目背后的原理和技术难点
- 描述要演练
  - 我做过什么业务
  - 负责的业务有什么业绩
  - 使用了什么技术方案
  - 突破了什么技术难点
  - 遇到了什么问题
  - 最大的收获是什么
- 引导找时机
- 优势要发挥
- 回答要灵活

## [#](https://cchroot.github.io/interview/pages/interview notes/interview.html#团队协作能力与带人能力)团队协作能力与带人能力

## [#](https://cchroot.github.io/interview/pages/interview notes/interview.html#职业竞争力)职业竞争力

1. 乐观积极
2. 主动沟通
3. 逻辑顺畅
4. 上进有责任心
5. 有主张，做事果断

## [#](https://cchroot.github.io/interview/pages/interview notes/interview.html#职业规划)职业规划

1. 职业竞争力
   - 业务能力
   - 思考能力
   - 学习能力
   - 无上限付出
   - 学会赞美
2. 职业规划
   - 目标是什么
     - 在业务上成为专家，在技术上成为行业大牛
   - 进阶的目标
     - 不断的学习积累个方面经验，以学习为主
   - 长期目标
     - 做几件有价值的事情，如开源作品、技术框架
   - 方式方法
     - 先完成业务上的主要问题，做到极致，然后逐步向目标靠拢

## [#](https://cchroot.github.io/interview/pages/interview notes/interview.html#面试总结)面试总结

- JD描述
  - 对于社招一定要看
- 简历
  - 对照JD改写出相吻合的简历，对于未掌握的技术栈快速复习、理解
- 自我介绍
  - **一定要打草稿**，展示什么优势、描述什么项目，切忌临场发挥

# 很久很久以前的面试面试复习二

## [#](https://cchroot.github.io/interview/pages/interview notes/interview2.html#es6)ES6

问题一：ES6模块化如何使用，开发环境如何打包？

- 基本语法为：import export(注意有无default)
- 可以用 webpack 或者 rollup 等打包工具打包
- 需要配置安装多个 babel ,以及 .babelrc 文件

问题二： Class 和普通构造函数的区别？

- class 在语法上更加贴合面向对象的写法
- class 实现继承更加易读、易理解
- 更易于写后 java 等后端语言的开发者快速入门使用
- 本质还是语法糖，使用 prototype

问题三：Promise 的基本使用和原理

- new Promise 实例，而且要 return
- new Promise 时要传入参数，函数有 resolve reject 两个参数
- 成功时执行 resolve() 失败时执行 reject()
- then 监听结果
- promise里面的then函数仅仅是注册了后续需要执行的代码，真正的执行是在resolve方法里面执行的
- 通过Promise.prototype.then和Promise.prototype.catch方法将观察者方法注册到被观察者Promise对象中，同时返回一个新的Promise对象，以便可以链式调用
- 被观察者管理内部pending、fulfilled和rejected的状态转变，同时通过构造函数中传递的resolve和reject方法以主动触发状态转变和通知观察者。

问题四： 总结一下 ES6 的其它常用功能

- let/const
- 多行字符串/模板变量
- 解构赋值
- 块级作用域
- 函数默认参数
- 箭头函数
- 拓展运算符
- Symbol类型
- Iterator 遍历器
- Generator 函数
- Async 函数

## [#](https://cchroot.github.io/interview/pages/interview notes/interview2.html#原型高级)原型高级

问题一：说一说原型的实际应用

- 描述一下 jquery 如何使用原型
- 描述一下 zepto 如何使用原型
- instanceof 原理
- 再结合自己的项目经验，说一个自己的开发例子

zepto 源码：

```js
(function (window) {
	//空对象
    var zepto = {}
	//构造函数
    function Z(dom, selector) {
        var i, len = dom ? dom.length : 0
        for (i = 0; i < len; i++) {
            this[i] = dom[i]
        }
        this.length = len
        this.selector = selector || ''
    }

    zepto.Z = function (dom, selector) {
		//注意new,返回一个实例
        return new Z(dom, selector)
    }
	
	//初始化函数，源码中更复杂
    zepto.init = function (selector) {
        var slice = Array.prototype.slice
        var dom = slice.call(document.querySelectorAll(selector))
        return zepto.Z(dom, selector)
    }
	
	//即zepto的$
    var $ = function (selector) {
        return zepto.init(selector)
    }
    window.$ = $

    $.fn = {
        css: function (key, value) {
            alert('css')
        },
        html: function (value) {
            return '这是一个模拟的 html 函数'
        }
    }
	//定义原型
    Z.prototype = $.fn
})(window)

//调用
var $p = $('p')
$p.css('font-size', '40px') //css()与html()是原型方法
alert($p.html())

var $div1 = $('#div1')
$div1.css('color', 'blue')
alert($div1.html())
```

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51

jquery 源码：

```js
(function (window) {
	//注意，第一步就找到了构造函数
    var jQuery = function (selector) {
        return new jQuery.fn.init(selector)
    }
	//初始化实例方法
    jQuery.fn = {
        css: function (key, value) {
            alert('css')
        },
        html: function (value) {
            return 'html'
        }
    }
	//定义构造函数
    var init = jQuery.fn.init = function (selector) {
        var slice = Array.prototype.slice
        var dom = slice.call(document.querySelectorAll(selector))

        var i, len = dom ? dom.length : 0
        for (i = 0; i < len; i++) {
            this[i] = dom[i]
        }
        this.length = len
        this.selector = selector || ''
    }
	//定义原型
    init.prototype = jQuery.fn

    window.$ = jQuery

})(window)

//调用
var $p = $('p')
$p.css('font-size', '40px')
alert($p.html())

var $div1 = $('#div1')
$div1.css('color', 'blue')
alert($div1.html())
```

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41

为什么要把原型方法放在 $.fn 或者 Jquery.fn？

因为要扩展插件(本质就是扩展原型方法)：

```js
$.fn.getNodeName = function(){
  return this[0].nodeName;
}
```

1
2
3

好处：

- 只有 $ 会暴露在 window 全局变量，限制暴露对象，避免全局污染
- 将插件扩展统一到 $.fn.xxx 这个接口，方便使用且统一

问题二：原型如何体现它的扩展性

- 说一下 jquery 和 zepto 的插件机制
  - 封装对象方法
  - 封装全局函数
  - 选择器插件
- 结合自己的开发经验，做过的基于原型的插件
- jQuery插件的机制很简单，就是利用jQuery提供的jQuery.fn.extend()和jQuery.extend()方法，扩展jQuery的功能。
- jQuery.fn.extend()多用于扩展上面提到的3种类型中的第一种，jQuery.extend()用于扩展后两种插件。这两个方法都接受一个参数，类型为Object。Object对象的“名/值对”分别代表“函数或方法名/函数主体”。

## [#](https://cchroot.github.io/interview/pages/interview notes/interview2.html#异步)异步

问题一：什么是单线程,和异步有什么关系？

- 单线程：只有一个线程，只能做一件事情
- 原因：避免 DOM 渲染的冲突。
  - 浏览器需要渲染 dom
  - js 可以修改 dom 的结构
  - js 执行的时候，浏览器 dom 渲染就会暂停
  - 两段 js 也不能同时执行（都修改 dom 就冲突了）
  - H5 中的 webworker 支持多线程，但是不能访问 dom
- 解决方案就是异步
- 实现方式就是 even-loop

问题二：什么是 even-loop

- 事件轮询，js 实现异步的具体解决方案
- 同步代码，直接执行
- 异步函数先放在异步队列中
- 待同步函数执行完毕，轮询执行异步队列的函数

问题三:是否用过 jquery 的 Deferred？

- jquery 1.5的变化
  - 无法改变 js 异步和单线程的本质
  - 只能从写法上杜绝 callback 这种形式
  - 它是一种语法糖形式，但是解耦了
  - 很好的体现了：开放封闭原则
- 使用 Jquery Deferred
  - 总结，dtd 的 API 可以分成两类，用意不同
  - 第一类：dtd.resolve dtd.reject
  - 第二类：dtd.then dtd.done dtd.fail
  - 这两类应该分开，否则后果很严重
- 初步引入 Promise 概念
- then() 方法返回一个 Promise 。它最多需要有两个参数：Promise 的成功和失败情况的回调函数，而它的行为与then中的回调函数的返回值有关：
  - 如果then中的回调函数返回一个值，那么then返回的Promise将会成为接受状态，并且将返回的值作为接受状态的回调函数的参数值。
  - 如果then中的回调函数抛出一个错误，那么then返回的Promise将会成为拒绝状态，并且将抛出的错误作为拒绝状态的回调函数的参数值。
  - 如果then中的回调函数返回一个已经是接受状态的Promise，那么then返回的Promise也会成为接受状态，并且将那个Promise的接受状态的回调函数的参数值作为该被返回的Promise的接受状态回调函数的参数值。
  - 如果then中的回调函数返回一个已经是拒绝状态的Promise，那么then返回的Promise也会成为拒绝状态，并且将那个Promise的拒绝状态的回调函数的参数值作为该被返回的Promise的拒绝状态回调函数的参数值。
  - 如果then中的回调函数返回一个未定状态（pending）的Promise，那么then返回Promise的状态也是未定的，并且它的终态与那个Promise的终态相同；同时，它变为终态时调用的回调函数参数与那个Promise变为终态时的回调函数的参数是相同的。

问题四：Promise 的基本使用和原理

- 基本语法回顾
- 异常捕获
- 多个串联
- Promise.all 和 promise.race
- Promise 标准
  - 三种状态：pending fulfilled reject
  - 初始状态是 pending
  - pending 变为 fulfilled,或者 pending 变为 reject
  - 状态是不可逆的
  - promise 实例必须实现 then 这个方法
  - then() 必须可以接收两个函数作为参数
  - then() 返回的必须是一个 promise 实例(对象)

```js
//基本使用
function loadImg(src) {
    var promise = new Promise(function (resolve, reject) {
        var img = document.createElement('img')
		//throw new Error("图片加载失败")//模仿语法报错
        img.onload = function () {
            resolve(img)
        }
        img.onerror = function () {
            reject('图片加载失败')
        }
        img.src = src
    })
    return promise
}

var src = 'https://www.imooc.com/static/img/index/logo_new.png'
var result = loadImg(src)
result.then(function (img) {
    console.log(1, img.width)
    return img // 非promise对象会自动包装成一个 promise 对象，并且img会作为参数传递，类似于：resolve(img)
}, function () {
    console.log('error 1')
}).then(function (img) {
    console.log(2, img.height)
	return img
},function(){
	console.log('error 2')
})
```

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29

```js
// 统一捕获异常
var src = 'https://www.imooc.com/static/img/index/logo_new.png'
var result = loadImg(src)
result.then(function (img) {
    console.log(1, img.width)
    return img
}).then(function (img) {
    console.log(2, img.height)
}).catch(function (ex) {
    // 统一捕获异常
    console.log(ex)
})
```

1
2
3
4
5
6
7
8
9
10
11
12

```js
//多个串联，第一个加载完后加载第二个，以此类推
var src1 = 'https://www.imooc.com/static/img/index/logo_new.png'
var result1 = loadImg(src1)
var src2 = 'https://img1.mukewang.com/545862fe00017c2602200220-100-100.jpg'
var result2 = loadImg(src2)
result1.then(function (img1) {
    console.log('第一个图片加载完成', img1.width)
    return result2  // 重要！！！
}).then(function (img2) {
    console.log('第二个图片加载完成', img2.width)
}).catch(function (ex) {
	//统一catch
    console.log(ex)
})
```

1
2
3
4
5
6
7
8
9
10
11
12
13
14

```js
//promise.all 接收一个 promise 对象的数组
//待全部完成后，统一执行 success
var src1 = 'https://www.imooc.com/static/img/index/logo_new.png'
var result1 = loadImg(src1)
var src2 = 'https://img1.mukewang.com/545862fe00017c2602200220-100-100.jpg'
var result2 = loadImg(src2)
Promise.all([result1, result2]).then(function (datas) {
	//接收到的 datas 是一个数组，依次包含了多个 promise 返回内容
    console.log('all', datas[0])
    console.log('all', datas[1])
})
//promise.race 接收一个包含多个 promise对象数组
//只要有一个完成，就执行 success
Promise.race([result1, result2]).then(function (data) {
	//data 即最先执行完成的 promises 的返回值
    console.log('race', data)
})
```

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17

问题五：介绍一下 async/await(和 promise 的区别、联系)

- then 只是将 callback 拆分了
- async/await 是最直接的同步写法，再也没有回调函数
- 使用了 promise ,并没有和 promise 冲突
- 但是：改变不了 js 单线程，异步的本质
- 需要 babel-polyfill

问题六：总结一下当前 js 解决异步的方案

- 回调函数（setTimeout()）
- 事件监听
- 发布订阅（jQuery.subscribe("done", f2);jQuery.publish("done");）
- promise
- generator
- async/await

## [#](https://cchroot.github.io/interview/pages/interview notes/interview2.html#virtual-dom)virtual dom

问题一： 什么是 vdom?

- virtual dom,虚拟 DOM
- 用 JS 模拟 DOM 结构
- DOM 变化对比，放在 JS 层来做（图灵完备语言）
- 目的是提高重绘性能
  - DOM 操作是“昂贵”的，JS 运行效率高
  - 尽量减少 DOM 操作，而不是 “推到重来”
  - 项目越复杂，影响就越严重
  - vdom 可以解决这个问题
- 核心api
  - h('标签名',{属性},[子元素]),对应 vue 中的vm._c，有子元素
  - h('标签名',{属性},[字符串]),对应 vue 中的vm._c，无子元素
  - patch(containter,vnode)，对应 vue 中的vm.*patch*,首次渲染
  - patch(vnode,newVnode)，对应 vue 中的vm.*patch*,diff 对比修改

问题二： 介绍一下 diff 算法？

- 知道什么是 diff 算法，是 linux 的基础命令
- vdom 中应用 diff 算法是为了找到需要更新的节点
- diff 实现，path(container,vnode);patch(vnode,newVnode)
- 核心逻辑，createElement 和 updataChildren

## [#](https://cchroot.github.io/interview/pages/interview notes/interview2.html#mvvm-和-vue)MVVM 和 Vue

问题一：说一下使用 Jquery 和使用框架的区别

- 数据和视图分离，解耦（开放封闭原则，数据可修改，DOM操作渲染封装）
- 以数据驱动视图，只关心数据变化，DOM 操作被封装

问题二：说一下对 MVVM（Model View ViewModel） 的理解，如何实现 MVVM？

- Model 数据、模型
- View 视图、模板（视图和模型是分离的）
- ViewModel 连接 Model 和 View（View 通过 DOM Listeners 事件监听 Model 来控制 Model 的改变，Model 通过 Data Bindings 操控视图的更新）

问题三：响应式，vue 中如何实现响应式

- 关键是理解 Object.defineProperty
- 将 data 的属性代理到 vm 上

```html
<div id="app">
    <input type="text" id="testId">
    <p id="show-text"></p>
</div>
<script>
	//双向绑定
    var obj = {}
    Object.defineProperty(obj, 'theValue', {
        get: function () {
            return obj
        },
        set: function (newValue) {
        	console.log("自动执行set方法")
            document.getElementById('testId').value = newValue
            document.getElementById('show-text').innerHTML = newValue
        }
    })
    document.addEventListener('keyup', function (e) {
        obj.theValue = e.target.value
    })
</script>
```

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21

```js
//将 data 的属性代理到 vm 上
var vm = {}
var data = {
    name: 'zhangsan',
    age: 20
}

var key, value
for (key in data) {
    (function (key) {
        Object.defineProperty(vm, key, {
            get: function () {
                console.log('get', data[key]) // 监听
                return data[key]
            },
            set: function (newVal) {
                console.log('set', newVal) // 监听
                data[key] = newVal
            }
        })
    })(key)
}
```

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22

问题四：模板引擎是什么？ vue 中如何解析模板? vue 的模板如何被渲染成 html?

- 跟 html 类似，但是有很大区别
- 模板本质是字符串，模板最终必须转换成 js 代码
- 有逻辑，如 v-if,v-for 等，逻辑必须用 js 才能实现（图灵完备）
- 最终还是要转换为 hmtl来显示，必须用 js 来转换
- 因此，模板最重要转换成一个 js 函数（通过 render 函数[vm._c,vm._s,vm._l...]）
- 知道 render 函数长什么样子，render 函数返回 vnode
- updateComponent 函数 **patch**()，首次直接渲染，第二次开始 diff 对比旧的 vnode

问题五：vue 的整个实现流程是怎么样的？

1. 第一步，解析模板成 render 函数
   1. with 用法
   2. 模板中用的所有信息都被 render 函数包含
   3. 模板中用到的 data 中的属性，都变成了 js 变量
   4. 模板中的 v-model v-for v-on 都变成了 js 逻辑
   5. render 函数返回 vnode
2. 第二步，响应式开始监听（data，watch等）
   - Object.defineProperty
   - 将 data 的属性代理到 vm 上
3. 第三步，首次渲染，显示页面，且绑定依赖
   1. 初次渲染，执行 updataComponent,执行 vm._render()
   2. 执行 render 函数，会访问到 vm.list 和 vm.title 等 data 上的数据
   3. 会被响应式的 get 方式监听到
      - 为何要监听 get,直接监听 set 不行吗？
      - data 中有许多属性，有些被用到，有些可能不被用到
      - 被用到的会走 get,不被用到的不会走 get
      - 未走 get 中的属性，set 的时候我们也无需关心
      - 避免不必要的重复渲染
   4. 执行 updateComponent,会走 vnode 的 patch 方法
   5. patch 将 vnode 渲染成 DOM,初次渲染完成
4. 第四部，data 属性变化，触发 rerender
   1. 修改属性，被响应式的 set 监听到
   2. set 中执行 updateComponent
   3. updateComponent 重新执行 vm._render()
   4. 生成的 vnode 和 preVnode，通过 patch 进行对比
   5. 渲染到 html 中

## [#](https://cchroot.github.io/interview/pages/interview notes/interview2.html#组件化和-react)组件化和 React

问题一：说一下对组件化的理解

- 组件的封装：封装视图、数据、变化逻辑
- 组件的复用：props 传递、复用

问题二：JSX 本质是什么

- JSX 语法（标签、JS 表达式、判断、循环、事件绑定）
- JSX 本质是语法糖，需要被解析成 JS 才能运行
- JSX 是独立的标准，可被其他项目使用

问题三：JSX 和 vdom 的关系

- 为何需要 vdom: JSX 需要渲染成 html，数据驱动视图
- React.createElement 和 h,都生成 vnode
- 何时 patch： ReactDOM.render(...) 和 setState
- 自定义组件的解析：初始化实例，然后执行 render，例如：

```js
//把 React.createElement(App,null); 转换成下面两句：
var app = new App(null); //这里传入的属性是 null，或者 {data:this.state.list},{addTitle:this.addTitle.bind(this)} 等数据或者函数
return app.render();
```

1
2
3

问题四： 说一下 setState 的过程

- setState 的异步：效果、原因（提高效率）
  - 可能会一次执行多次 setState
  - 你无法规定、限制用户如何使用 setState
  - 没必要每次 setState 都重新渲染，考虑性能
  - 即便是每次重新渲染，用户也看不到中间的效果(执行 JS 时，DOM 渲染是暂停的)
- vue 修改属性也是异步的：效果、原因（提高效率）
- setState 的过程：最终走到 patch(preVnode,newVnode)
  - 每个组件实例，都有 renderComponent 方法
  - 执行 renderComponent 会重新执行实例的 render
  - render 函数返回 newVnode ,然后拿到 preVnode
  - 执行 patch(preVnode,newVnode)

## [#](https://cchroot.github.io/interview/pages/interview notes/interview2.html#react-vs-vue)React vs Vue

- 两者的本质区别
  - vue 本质是 MVVM 框架，由 MVC 发展而来
  - React 本质是前端组件化框架，由后端组件化发展而来
  - 但并不妨碍他们两者都能实现相同的功能
- 看模板的和组件化的区别
  - 模板
    - vue 使用模板（最初由 angular 提出）
    - React 使用 JSX
    - 模板语法上，我更加倾向于 JSX
    - 模板分离上，我更加倾向于 Vue
  - 组件化
    - React 本身就是组件化，没有组件化就不是 React
    - vue 也支持组件化，不过是在 MVVM 上的扩展
    - 对于组件化，我更加倾向于 React ,做的彻底而清晰
- 两者共同点
  - 都支持组件化
  - 都是数据驱动视图

## [#](https://cchroot.github.io/interview/pages/interview notes/interview2.html#hybird)Hybird

问题一：hybird 存在的价值，为何会用 hybrid？

- hybird 是客户端和前端的混合开发
- 没有访问手机内部信息功能的权限，所以可以快速迭代更新，无需审核
- 体验流畅（和 NA 的体验基本类似）
- 减少开发和沟通成本，双端公用一套代码

问题二: webview

- 是 app 中的一个组件（app 可以有 webview，也可以没有）
- 用于加载 h5 页面，即一个小型的浏览器内核

问题三： file:// 协议

- file 协议：本地文件快
- http(s) 协议：网络加载，慢

问题四：hybrid 使用场景：

- 不是所有的场景都适合 hybrid
- 使用 NA:体验要求极致，变化不频繁
- 使用 hybrid： 体验要求高，变化频繁
- 使用 h5:体验无要求，不经常使用

问题五： hybrid 具体实现：

- 前端做好静态页面(html,js,css),将文件交给客户端
- 客户端拿到静态页面，以文件形式存储在 app 中
- 客户端在一个 webview 中使用 file 协议加载静态文件

问题六： app 发布之后，静态文件如何实时更新？

- 分版本，有版本号，如 201803211015
- 将静态文件压缩成 zip 包，上传到服务器
- 客户端每次启动，都去服务端检查版本号
- 如果服务端本本号大于客户端版本号，就去下载最新的 zip 包
- 下载完之后解压包，然后将现有文件覆盖

问题七: hybrid 和 h5 的区别

- 优点
  - 体验好，跟 NA 体验基本一致
  - 可快速迭代，无需 app 审核（关键）
- 缺点
  - 开发成本高，联调、测试、查 bug 都比较麻烦
  - 运维成本高，更新流程复杂
- 适用场景
  - hybrid：产品的稳定功能，体验要求高，迭代频繁（产品型）
  - h5：单词的运营活动（如 xx 红包）或不常用功能（运营型）

问题八：前端和客户端通讯

- 静态页面如何获取内容，例如：新闻详情页，前端如何获取新闻内容？
  - 不能用 ajax 获取，第一跨域，第二速度慢
  - 客户端获取新内容(客户端可以提前获取)，然后 js 与客户端通讯拿到内容，再渲染；客户端获取内容可以提前获取不像 js 渲染完才可以通过 ajax 请求获取
  - 总结起来就是：js 访问客户端，传递参数和回调函数，客户端通过回调函数返回内容
- JS 和客户端通讯的基本形式
  - 通过 schema 协议——前端和客户端通讯约定
  - 调用能力，传递参数，监听回调
- schema 协议简介和使用
- schema 使用封装
- 内置上线
  - 更快更安全