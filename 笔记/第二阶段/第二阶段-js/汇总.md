## 一、变量

###### 储存数据

### 1、变量的命名规则：

​		以字母、下划线开头，后面跟数字、字母、下划线

### 2、变量的声明

​		var/let/const

​				1、定义一个，

​				2、定义多个

​				3、var的使用场景

​						任何时候都能用

​						预解析有提升

​						var定义的全局变量会在window上

​		let - 通常在循环的时候，循环中有异步操作/事件

### 3、隠式声明

​	例：var a = b = c = 10   ---   var a = 10       b = 10     c = 10

### 4、作用域

​	1、定义在不同的地方，这个变量能在不同的地方起到作用

​			a、全局定义的

​						在全局都能生效

​						任何函数外面

​						函数里

​						window的属性

​			b、在函数内定义的

​					只能在当前函数内部使用

​					函数内的函数内

​	2、当给一个变量进行赋值的时候，先在当前作用域中找有没有定义过这个变量，如果		没有，就去上一级作用域中找，...一直往上找，直到全局，如果也没有，就在全局定		义这个变量，然后赋值

​	3、当给变量做其他操作的时候，先在当前作用域中找有没有定义过这个变量，如果没		有，就去上一级作用域中找，...一直到全局，如果也没有找到，就报错

### 5、数据类型：

​			typeof（被检测内容）

## 二、运算符

### 1、赋值运算一

​		=：同一个变量可以多次赋值，后面的值覆盖前面的

### 2、算术运算

​		+    加

​		-	 减

​		*    乘

​		/    除

​		%  取余

### 3、字符串的拼接运算

​		+ ：

​			1、如果两边都是数字，那进行的是数学中的加法运算。但是两边只要一边是字符					串的话，那是将两边的值连接成一个。也就是所谓的字符串的拼接。

​			2、拼接运算的`+`左右两边，只要有一边是字符串就进行拼接运算，具体情况有：					数字+字符串、字符串+数字、字符串+字符串。

### 4、关系运算（比较运算）

| 运算符 | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| `>`    | 大于                                                         |
| `>=`   | 大于等于                                                     |
| `<`    | 小于                                                         |
| `<=`   | 小于等于                                                     |
| `==`   | 等于（主要用于判断两边的值是否相等）                         |
| `===`  | 全等于（先判断两边的类型是否相等，类型相等再判断值是否相等） |

### 5、赋值运算二

| 符号 | 描述                     | 示例                                         |
| ---- | ------------------------ | -------------------------------------------- |
| +=   | 自己先加后，再赋值给自己 | var a = 1; a += 2; 相当于a先加2，结果赋值给a |
| -=   | 自己先减后，再赋值自己   | var a = 1; a -= 1; 相当于a先减1，结果赋值给a |
| *=   | 自己先乘后，再赋值自己   | var a = 1; a *= 3; 相当于a先乘3，结果赋值给a |
| /=   | 自己先除后，再赋值自己   | var a = 4; a /= 2; 相当于a先除2，结果赋值给a |
| %=   | 自己先余后，再赋值自己   | var a = 5; a %= 2; 相当于a先余2，结果赋值给a |

### 6、类型转换

#### 	a、转换为布尔型

```shell
	语法：
	Boolean(arg)
```

​			非0数字转换为布尔型为true，0转换为布尔型为false

​			非空字符串转换为布尔型为true，空字符串转换为布尔型为false

​			undefined转换为布尔型为false

​			null转换为布尔型为false

#### 	b、转换为字符串

```shell
	语法：
		String(arg)
```

​			true转换为字符串仍为 true，false转换为字符串仍为false

​			null转换为字符串扔为null

​			undefined转换为字符串仍为undefined

#### 	c、转换为数字

```shell
	语法：
		Number(str)
```

​			NaN代表不是数字，但是他是数字类型（没有意义的数字）

​			非数字字符串转换后都是NaN（NaN是一个不是数字的数字类型）

​			true转为数字为1，false转为数字为0

​			undefined转换为数字为NaN

​			null转化为数字为0

#### 	d、使用函数强制转换为数字

```shell
	语法：
		parseInt(arg) # 强制转换为整数
		parseFloat(arg) # 强制转换为小数
```

​			小数转换为整数只取整数，向下取整

​			首位非数字的字符串强转为整数为NaN，首位是数字的字符串强转为整数是首位			的数字

​			布尔型强转为**数字**为NaN

​			undefined强转为**数字**为NaN

​			null强转为**数字**为NaN



#### 	e、使用`toString()`

​		方法强制转换为字符串，转换结果和String()函数一样

```javascript
        var a = 123456;
        b = true;
        var c = a.toString();
        var d = b.toString();
        console.log(c);
        console.log(typeof c);
        console.log(d);
        console.log(typeof d);
```

​		注意：这个方法不能给undefined和null使用

#### 	f、隐形转换

​			数学运算时转换为数字型，例：

```javascript
        var str = "100"
        var a = str%10; // 乘和除以及求余都行
        var b = true + 1
        console.log(a);
        console.log(b);
```

​		比较运算时发生隐形转换，例：

​		如果两个值都是字符串，则进行比较编码值

​		如果有一个值为数字或布尔型，则转换为数字进行比较

​		字符串进行比较的时候首字符进行比较，相等再进行后面的字符比较。参照阿斯克		码表。

​		拼接运算时发生字符串转换，例：

```javascript
        var a = "1";
        console.log(a+12); // 112
```

#### 	g、逻辑运算

​			逻辑运算一般用于判断多个关系运算，得出最后结果。

| 运算符         | 描述                                                    |
| -------------- | ------------------------------------------------------- |
| &&（与，并且） | 左右两边都为true，最后结果才为true，否则就是false       |
| \|\|（或者）   | 左右两边只要有一个true，最后结果就为true，否则就是false |
| ！（非，取反） | 将true处理为false，将false处理为true                    |

​			逻辑运算最后得出的结果也是布尔型。双重否定等于肯定。

#### 	h、自增自减运算

​			符号：++	表示让一个数字递增1  放前后有区别

​			符号:	--	符号：--	表示让一个数字递减1

​				使用方法和注意事项与递增一样。

​				<font color="red">递增递减运算需要使用变量，不能使用具体数字</font>



## 二、逻辑分支

#### 	1、单分支

#### 	2、双分支

#### 	3、多分子

​		1、2、3、只选一条路走

#### 	4、switch多路判断

​			如果有多个分支，都在判断相等。此时使用switch更好

```shell
	语法：
        switch(变量){
            case 值1:
                执行的代码块
            break;
            case 值2:
                执行的代码块
            break;
            。。。
            default:
                执行代码块
        }
```

使用说明：

1. break表示当前分支执行后就结束switch的运行，后续代码不再运行
2. default可以理解为判断语句中的else
3. case理解为if来判断这个变量是否全等于某个值
4. witch判断使用的是<font color="red">**全等于(===)**</font>

#### 5、switch 穿透写法

​	如果case后面不写break，那当前case执行后，会继续执行后面的case中的代码

#### 6、三元运算

​	if双分支有一种简写方式：

```shell
条件?条件成立时运行的代码段:条件不成立时运行的代码段;
```

​	三元运算有个特点：可以将整个表达式当做一个值，可以赋值给一个变量，也可以输出



## 三、循环结构

#### 1、while循环结构

```shell
	语法：
        while(条件语句){
            条件成立执行的代码
        }	
```

#### 2、do while循环结构

​	do while循环会先执行一次，不管条件是否成立，先执行一次，后面的流程和while循环一样

#### 3、for循环结构



```shell
	语法：
        for(声明变量并赋初始值;条件表达式;每重复一次后变量的变化规律){
            重复执行的代码块
        }
# 在语法中的声明变量并赋初始值，就是从哪里开始重复；条件表达式可以限定重复在什么时候停止（当条件不成立的时候）；通过每次重复变量的变化和条件表达式可以知道要重复多少次
```



#### 4、循环中的跳转关键字

​	a、continue关键字，可以跳过当前这次的循环，直接进行下一次的循环。

​	b、break关键字，可终止循环，直接让整个循环结束运行。



## 四、函数

#### 1、自定义函数

> ```
>     function 函数名(){
>         代码段
>     }
> # function是一个关键字，函数名自定义，定义规则和变量的定义规则相同
> 函数的调用：
> 	语法：
> 	函数名()
> ```

#### 2、系统内置函数

#### 3、匿名函数

> ```shell
>   定义：
>     语法：
>         function(){
>             代码段
>         }
>    #定义好函数以后，其实开始是不知道this是谁的
>    #等你调用函数的时候，怎么调用就决定了this是谁
>    #如果形参没有对应的实参，形参的值是undefined
>    #如果函数没有返回值，默认返回undefined
> ```
>

​	当然匿名函数也可以传递参数。

​	调用：匿名函数的调用是在定义的时候调用

```shell
    语法：
        (function(形参){
            代码段
        })(实参)
    #很简单，就是在大括号后面加小括号就是调用。
    #也可以将匿名函数赋值给变量，调用的时候使用变量名来调用。
    #通过事件来调用匿名函数
```

#### 4、自调用函数

#### 5、箭头函数

#### 6、递归函数

​		递归函数就是在函数中调用自己。

#### 7、构造函数

```
	用new创建出来的变量都是对象

​	当我们使用new来创建一个对象的时候，这个函数就成了构造函数。

​	使用new关键来创建对象的函数，叫做构造函数。

​	我们可以为这个对象添加属性和方法。
```



#### 8、作用域

​		a、函数外边的变量叫做全局变量，可以在函数外面和函数里面使用。

​		b、函数内部的变量叫做局部变量，只能在函数内部使用。

​		c、有一种情况比较特殊，函数内部声名的变量也是全局变量。

​	总结：

​		a、函数外边使用的变量是全局变量，要在全局内找，可以是函数外部声名的变量也			可以是函数内部的隐式声名的变量。

​		b、函数内部使用的变量是局部变量，先从局部找，如果局部没有，再从全局中找。

#### 9、return返回值

> ```sh
>     语法：
>         function 函数名(){
>             return 返回的结果
>         }
>     #return的作用：
>         1. 终止代码继续运行
>         2. 在函数中返回一个内容
> ```

#### 10、变量的声明提升

​	浏览器中有一段程序专门用来解析js代码， 叫做js解析器。js解析器在执行js代码的时候，分两步进行：

1. 预解析js代码

   预解析的过程，就是查找代码中的var和function这两个关键字，找到以后，将变量和函数存到了一个地方，就叫仓库吧，并给他们赋一个初始值，变量的初始值为undefined，函数的初始值为代码段。

2. 开始按顺序一行一行解读代码

   解读代码的时候，仓库中的变量和函数的值会随着代码的解读而发生变化，也就是变量的赋值和函数的调用。

预解析分为变量的预解析和函数的预解析，也就是代码在执行之前先进行解析，将变量和函数的声名放在当前作用域的最前面。

总结：

1. 用var关键字声名的变量，将变量的声名提升到当前作用域的最前面，赋值不提升
2. 自定义的函数整体提升到当前作用域的最前面
3. 函数同名，后面的会覆盖前面的
4. 变量和函数同名，函数优先提升



## 五、对象

#### 1、引入

​	复杂的数据，一个变量中存了多个数据

#### 2、定义对象

```shell
    var obj = {};
    var obj = new Object();
    #对象存储数据的格式 - 键值对。
    语法：
        var obj = {
            键:值,
            键:值,
            ...
        };
        # 或
        var obj = new Object({
            键:值,
            键:值,
            ...
        });
	#语法规则：
	1. 键，也叫作对象的属性，必须是字符串，但是这个字符串在不包含连字符的时候，可以		不加引号 - 建议加上
	2. 值可以是任意类型，包括：数字、字符串、布尔、对象、函数...
	3. 键值对之间使用逗号隔开
	4. 键值对之间没有顺序，先写哪个后写哪个没有关系
```

#### 3、访问对象

​	获取这个对象中的某个属性

```shell
对象.属性名	#  这种方式的属性名不用加引号
# 或
对象[属性名]  #  这种方式的属性名必须加引号
```

对象的属性名类似于变量名，只不过是定义在大括号中的变量，不会被大括号外部的变量名覆盖 - 不会被外部的变量污染。

#### 4、遍历对象

```shell
	#遍历的意思就是将每一个值都访问一遍。
	#js提供了专门用来遍历对象的操作语法：
	for(var attr in obj){
	#这里的attr代表对象属性名
	#obj表示这个对象
	}
	#注：只用来遍历对象，遍历数组、伪数组都是用for i=0
```

#### 5、方法

```shell
	a、对象的值可以是任意类型。函数也可以当做一种数据类型来看待。也就是说对象值也可以是函数。
	b、如果对象的某个属性的值是一个函数，就可以将这个属性叫做对象的方法。
	#方法的访问和属性是一样的：
	obj2.study(); // 因为函数执行需要调用，所以需要加小括号
```

#### 6、操作

```
	给对象添加属性：
        obj.name = '李四';
        obj["age"] = 12;
    #如果给已经存在的属性赋值，就是修改属性的值
    
```



## 六、数组Array

#### 1、数组概念

​		内存中的多个容器排列起来，组成的一个大容器。

​		数组是计算机空间中一段有序的连续空间，使用一个变量名表示。

#### 2、创建数组：

```shell
    语法一：
        var arr = []; # 创建了一个空数组
        var arr = ["张三","李四","王五"]; # 创建了一个数组，里面存了三个姓名
    语法二：
        var arr = new Array(); # 创建了一个空数组
        var arr = new Array(3); # 创建了一个长度为3的数组
        var arr = new Array("张三","李四","王五"); # 创建了一个数组，里面存了三个姓名
```

#### 3、数组的操作

​	a、访问数组中的元素：数组[下标]

​	b、查看数组中元素的个数：**`数组.length`**

​		说明：数组的长度可以访问，也可以赋值，用来修改数组的长度。

​	c、给数组添加元素：数组[下标] = 值

​	d、修改数组中的元素的值：数组[下标] = 值

​	e、清空数组：

​				arr = []

​				arr.length = 0

> ​	数组总结：
>
> ​		1.数组的第一个元素的下标永远是0；
>
> ​		2.数组的最后一个元素的下标永远是`数组的长度-1`
>
> ​		3.数组的空间是可扩展的。可以在其后面继续添加元素。

#### 4、遍历数组

​	for i=0

#### 5、二维数组

​		包含数组的数组，叫做多维数组，我们用的最多的就是二维数组。

#### 6、基础类型和引用类型

​		简单类型传递值，复杂类型传递地址

​		简单数据类型：number、string、boolean、undefined、null

​		复杂数据类型：Array、function、Object、函数

#### 7、数组操作的方法

​		**a、array.splice()  -  数组任意地方删除或者添加元素**

```js
// 	array.splice(start,deleteCount)		删除元素
//		- start  开始
//		- deleteCount	删除个数
//	array.splice(start,deleteCount,item)	删除+添加，三个参数是在原来删除的位置上新加几个元素
#特殊：
//	array.splice(start,0,item)  就是在某个位置新加元素
```

​		**b、Array.concat()  -  连接数组**

```js
//	array.concat(value,...)
//	 参数 - value,...  要增加到array中的值，可以是任意多个
//	 返回值 - 是一个新数组
```

​		**c、Array.join()  -  将数组元素连接起来以构建一个字符串**

```js
//	array.join(separator)
//	 参数 - separator：在返回的字符串中用于分割数组元素的字符或字符串，他是可选的。如果省略了这个人参数，用逗号作为分隔符。
//	 返回值 - 一个字符串，两个元素之间插入separator字符串而生成
```

​		**d、Array.length   -  数组的大小**

​		**e、Array.pop()   -  删除并返回数组的最后一个元素**

```js
//	 返回值  - array的最后一个元素。
//		如果数组已经为空，则pop()不改变数组，返回undefined。 
```

​		**f、Array.push()  -  给数组添加元素**

```js
//	array.push(value,...)
//	 参数,...  要添加到尾部的值，可以是一个或多个
//	 返回值 - 把指定的值添加到数组后的新长度
//	修改数组
```

​		**g、Array.reverse()   -   颠倒数组中元素的顺序**

```js
//	array.reverse()
//		在原数组上实现这一操作
```

​		**h、Array.shift()   -   将数组头部元素移出数组**

```js
//	array.shift()
//	 返回值 - 数组原来的第一个元素。
//	   将array的第一个元素移出数
//		修改原来的数组
```

​		**i、Array.unshift()   -   在数组头部插入一个元素**

```js
//	array.unshift(value, ...) 
//	  参数	-	value, ... 
//		要插入数组头部的一个或多个值。
//		返回值	-	数组的新长度
```

​		**j、Array.slice()	-	返回数组的一部分**

```js
//	array.slice(start, end)
//	参数
//	start 
//		数组片段开始处的数组下标。如果是负数，它声明从数组尾部开始算起的位置。 也就是说，-1指最后一个元素，-2指倒数第二个元素，以此类推。
//	end 
//		数组片段结束处的后一个元素的数组下标。如果没有指定这个参数 包含从start开始到数组结束的所有元素。如果这个参数是负数， 从数组尾部开始算起的元素。
//	返回值
//		一个新数组，包含从start到end(不包括该元素)指定的array元素。
```

​		**k、Array.sort( )	-	对数组元素进行排序**

```js
//	array.sort( ) 
//	array.sort(orderfunc)
//	参数	-	orderfunc 
//		用来指定按什么顺序进行排序的函数，可选。
//	返回值	-	对数组的引用。注意，数组在原数组上进行排序，不制作副本。
```

​		**m、Array.toString( )	-	将数组转换成一个字符串**

```js
//	array.toString( )
//	返回值
//		array的字符串表示。
//	抛出
//		TypeError 
//			调用该方法时，若对象不是Array，则抛出该异常。
//	描述
//		数组的toString()方法将把数组转换成一个字符串，并且返回这个字符串。
```

## 七、字符串

### 1、阿斯克码

​		0-9	- 	

​		a-z	-	

​		A-Z	-	

### 2、字符串的比较

​	通过阿斯克码表，我们可以得出一些字符串比较的规律：

​		a、字母比数字大

​		b、小写字母比大写字母大

​		c、字母越靠后越大

### 3、字符串的基本操作

​	<font color="red">字符串也可以通过下标获取字符</font> --可以遍历

​	<font color="red">字符串是只读数据类型，不能添加新字符，不能修改字符串中的字符，不能删除某个字符</font>

### 4、字符串常见的API

#### 	a、String.length  

###### 		-  	字符串的长度

```js
#语法
	string.length 
#描述
	属性String.1ength是一个只读整数，它声明了指定字符串string中的字符数。对于任何一个字符串s，它最后一个字符的下标都是s.1ength-1。用for/in循环不能枚举出字符串的length属性，用delete运算符也不能删除它。

```



#### 	b、tring.charAt( )

###### 		-	返回字符串中的第n个字符

```js
#语法
	string.charAt(n)
#参数
	n 
		应该返回的字符在string中的下标。

#返回值
	字符串string的第n个字符。

#描述
	方法String.charAt()返回字符串string中的第n个字符。字符串中第一个字符的下标值是0。如果参数n不在0和string.length-1之间，该方法将返回一个空字符串。注意，JavaScript并没有一种有异于字符串类型的字符数据类型，所以返回的字符是长度为1的字符串。
```



#### 	c、string.charCodeAt(n)

###### 		-	返回字符串中的第n个字符的编码

```js
#语法
	string.charCodeAt(n)
#参数
	n 
		返回字符串中的第n个字符的编码

#返回值
	string中的第n个字符的Unicode编码。这个返回值是0～65535之间的16位整数。

#描述
	方法charCodeAt()与charAt()执行的操作相似，只不过前者返回的是位于指定位置的字符的编码，而后者返回的则是含有字符本身的子串。如果n是负数，或者大于等于字符串的长度，则charCodeAt()返回NaN。
```



#### 	d、String.fromCharCode( )

###### 		-	从字符编码创建—个字符串

```js
#语法
	String.fromCharCode(c1, c2, ...) 
#参数
	c1, c2, ... 
		零个或多个整数，声明了要创建的字符串中的字符的Unicode编码。
#返回值
	含有指定编码的字符的新字符串。
#描述
	这个静态方法提供了一种创建字符串的方式，即字符串中的每个字符都由单独的数字 Unicode编码指定。注意，作为—种静态方法，fromcharCode()是构造函数 String()的属性，而不是字符串或String对象的方法。
	String.charCodeAt()是与String.fromCharCode()配套使用的实例方法，它提 供了获取字符串中单个宁符的编码的方法。 
```



#### 	e、String.indexOf( )

###### 		-	检索字符串

```js
#语法
    string.indexOf(substring) 
    string.indexOf(substring,start)
#参数
	substring 
		要在字符串string中检索的子串。
	start 
		一个可选的整数参数，声明了在字符串String中开始检索的位置。它的合法取值是0(字符串中的第一个字符的位置)到string.length-1(字符串中的最后一个字符的位置)。如果省略了这个参数，将从字符串的第一个字符开始检索。
#返回值
	如果在string中的start位置之后存在substring返回出现的第一个substring 的位置。如果没有找到子串substring返回-1。
#述
	方法string.indexOf()将从头到尾的检索字符串string，看它是否含有子串 substring。开始检索的位置在字符串string的start处或string的开头(没有 指定start参数时)。如果找到了一个substring那么String.indexOf()将返回 substring的第一个字符在string中的位置。string中的字符位置是从0开始的。 
	如果在string中没有找到substring，那么String.indexOf()方法将返回-1。 
```



#### 	f、string.lastIndexOf( ) 

###### 		-	从后向前检索一个字符串

```js
#语法
    string.lastIndexOf(substring) 
    string.lastIndexOf(substring, start)
#参数
	substring 
		要在字符串string中检索的子串。
	start 
		一个可选的整数参数，声明了在字符串string中开始检索的位置。它的合法取值是0(字符串中的第一个字符的位置)到string.1ength-1(字符串中的最后一个字符的位置)。如果省略了这个参数，将从字符串的最后一个字符处开始检索。
#返回值
	如果在string中的start位置之前存在substring那么返回的就是出现的最后一个	substring的位置。如果没有找到子串substring那么返回的是-1。
#描述
	方法String.1astIndexOf()将从尾到头的检索字符串string看它是否含有子串 substring。开始检索的位置在字符串string的start处或string的结尾(没有 指定start参数时)。如果找到了一个substring，那么String.lastIndexOf()将返回substring的第一个字符在string中的位置。由于是从尾到头的检索一个字符串，所以找到的第一个substrlng其实是strlng中出现在位置start之前的最后一个substring。 
	如果在string中没有找到substring，那么该方法将返回-1。
	注意，虽然String.1astIndexOf()是从尾到头的检索字符串string，但是它返回的字符位置仍然是从头开始计算的。字符串中第一个字符的位置是0，最后—个字符的位置是string.1ength-1。
```



#### 	g、String.substr( )

###### 		-	抽取一个子串

```JS
#语法
	string.substr(start, length)
#参数
	start 
		要抽取的子串的起始下标。如果是一个负数，那么该参数声明从字符串的尾部开始算起的位置。也就是说，-1指字符串中的最后—个字符，-2指倒数第二个字符，以此类推。
	length 
		子串中的字符数。如果省略了这个参数，那么返回从string的开始位置到结尾的子串。
#返回值
	一个字符串的副本，包括从string的start处(包括start所指的字符)开始的1ength个字符。如果没有指定length，返回的字符串包含从start到string结尾的字符。
#描述
	substr()将在string中抽取并返回一个子串。但是它并不修改string。
	注意，substr()指定的是子串的开始位置和长度，它是String.substring()和String.splice()的一种有用的替代方法，后两者指定的都是起始字符的位置。但要注意，ECMAScript没有标准化该方法，因此反对使用它。
```



#### 	h、tring.substring( )

###### 		-	返回字符串的一个子串

```JS
#语法
	string.substring(from, to)
#参数
	from 
		一个整数，声明了要抽取的子串的第一个字符在string中的位置。
	to 
		一个可选的整数，比要抽取的子串的最后一个字符在string中的位置多1。如果省略了该参数，返回的子串直到字符串的结尾。
#返回值
	一个新字符串，其长度为to-from，存放的是字符串string的一个子串。这个新字符串含有的字符是从string中的from处到to-1处复制的。
#描述
	String.substring()将返回字符串string的子串，由from到to之间的字符构成， 包括位于from的字符，不包括位于to的字符。
	如果参数from与to相等，那么该方法返回的就是一个空串(即长度为0的字符串)。 如果from比to大，那么该方法在抽取子串之前会先交换这两个参数。如果开始下标或结束下标为负数，则先将负数替换成0，然后再截取
	要记住，该子串包括from处的字符，不包括to处的字符。虽然这样看来有违直觉， 但这种系统一个值得注意重要特性是，返回的子串的长度总等于to-from。

```



#### i、String.slice( )

###### 		-	抽取一个子串

```JS
#语法
	string.slice(start, end)
#参数
	start 
		要抽取的片段的起始下标。如果是负数，那么该参数声明了从字符串的尾部开始算起的位置。也就是说，-1指字符串中的最后一个字符，-2指倒数第二个字符，以此类推。
	end 
		紧接着要抽取的片段的结尾的下标。如果没有指定这一参数，那么要抽取的子串包括start到原字符串结尾的字符串。如果该参数是负数，那么它声明了从字符串的尾部开始算起的位置。
#返回值
	一个新字符串，包括字符串string从start开始(包括start)到end为止(不包 括end)的所有字符。
#描述
	方法slice()将返回一个含有字符串string的片段的字符串或返回它的一个子串。 但是该方法`不修改string。`
	String对象的方法slice()、substring()和substr()(不建议使用)都返回字符串的指定部分。slice()比substring()要灵活一些，因为它允许使用负数作为参数。slice()与substr()有所不同， 因为它用两个字符的位置指定子串，而substr()则用字符位置和长度来指定子串。还要注意的是，String.slice()与Array.slice()相似。
```



#### j、tring.split( )

###### 			-	使用指定的分隔符将字符串分割成多部分组成数组

```shell
#语法
	string.split(delimiter, limit)
#参数
	delimiter 
        字符串或正则表达式，从该参数指定的地方分割string。
	limit 
		这个可选的整数指定了返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数字。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。ECMAScriptv3标准化了该参数，JavaScript 1.2和JScript 3.0实现了它。JavaScript 1.1没有实现它。
#返回值
	一个字符串数组，是通过在delimiter指定的边界处将字符串string分割成子串创建的。返回的数组中的子串不包括delimiter自身，但下面列出的情况除外。
#描述
	方法split()将创建并返回一个字符串数组
	1. 分隔符是可选项。如果省略了分隔符，则将整个字符串当做数组的元素，如果是空字符串，则会在每个字符中间进行分割
	2. 要保留的个数是可选项。如果省略了个数，则返回全部的个数，如果加上个数，则是设置了数组中元素的个数。
	注意，String.split()执行的操作与Array.join()执行的操作相反。

```



#### k、String.replace( )

###### 			-	使用新的字符或子字符串替换原来在字符串中的一部分

```JS
#语法
	string.replace(regexp, replacement)
#参数
	regexp 
		声明了要替换的模式的RegExp对象。如果该参数是一个字符串，则将它作为要检索的直接量文本模式，而不是首先被转换成RegExp对象。
	replacement 
		一个字符串，声明的是替换文本或生成替换文本的函数。详见描述部分。
#返回值
	一个新字符串，是用replacemenc替换了与regexp的第一次匹配或所有匹配之后得到的。
#描述
	字符串string的方法replace()执行的是查找并替换的操作。它将在string中查找与regexp相匹配的子串，然后用replacement替换这些子串。如果regexp具有全局性质g，那么replace()将替换所有的匹配子串。否则，它只替换第一个匹配子串。`如果第一个参数是空字符串，则会将新内容拼接到原字符串前面`
	replacement可能是字符串或函数。如果它是一个字符串，那么每个匹配都将由字符 串替换。但replacement中的$字符具有特殊的含义。
	ECMAScript v3规定，replace()方法的参数replacement可以是函数而不是字符串，JavaScipt 1.2和JScript 5.5实现了这一特性。在这种情况下，每个匹配都调用该函数，它返回的字符串将作为替换文本使用。该函数的第一个参数是匹配模式的字符串。接下来的参数是与模式中的子表达式匹配的字符串，可以有0个或多个这样的参数。接下来参数是一个整数，声明了匹配在string中出现的位置。最后一个参数是string自身。

```

#### 	m、String.trim()

###### 			-	去除字符串左右两边的空白

```JS
#语法：
	String.trim();
#描述
	1. 去除的是左右两边的空白，不会去除字符串中间的空白
	2. 只去除左边的空白使用：`trimLeft`方法；只去除右边的空白使用：`trimRight`方法
```



#### n、大小写转换方法

​	-	将字符串中所有小写字母转为大写字母，使用：`toUpperCase`方法

​	-	将字符串中所有小写字母转为大写字母，使用：`toLowerCase`方法

```JS
#语法：
    字符串.toUpperCase(); # 转为大写
    字符串.toLowerCase(); # 转为小写
```

#### o、String.concat( )

###### 		-	连接字符串

```js
#语法
	string.concat(value, ...) 
#参数
	value, ... 
		要连接到string上的一个或多个值。
#返回值
	把每个参数都连接到字符串string上得到的新字符串。
#描述
	方法concat()将把它的所有参数都转换成字符串(如果必要)，然后按顺序连接到字符串string的尾部，返回连接后的字符串。注意，string自身并没有被修改。 
```

#### p、String.match( )

###### 		-	找到一个或多个正则表达式的匹配

```js
#语法
	string.match(regexp)
#参数
	regexp 
		声明了要匹配的模式的RegExp对象。如果该参数不是RegExp对象，则首先将把它传递给RegExp()构造函数，把它转换成RegExp对象。
#返回值
	存放匹配结果的数组。该数组的内容依赖于regexp是否具有全局性质g。下面详细说明了这个返回值。
#描述
	方法match()将检索字符串string，以找到一个或多个与regexp匹配的文本。这个方法的行为很大程度上依赖于regexp是否具有性质g。
	如果regexp没有性质g，那么match()就只能在string中执行一次匹配，如果没有找到任何匹配的文本，match()将返回null。否则，它将返回一个数组，其中存放了与它找到的匹配文本有关的信息。该数组的第0个元素存放的是匹配文本，其余的元素存放的是与正则表达式的子表达式匹配的文本。除了这些常规的数组元素之外，返回的数组还含有两个对象属性。index属性声明的是匹配文本的起始字符在string中的位置，input属性声明的是对string的引用。 
	如果regexp具有标志g，那么match()将执行全局检索，找到string中的所有匹配子串。如果没有找到任何匹配的子串。它将返回null。如果找到了一个或多个匹配子串，它将返回一个数组。不过，全局匹配返回的数组的内容与前者大不相同，它的数组元素存放的是string中的所有匹配子串，而且它也没有index属性和input属性。注意，在全局匹配的模式下，match()既不提供与子表达式匹配的文本的信息，也不声明每个匹配子串的位置。如果你需要这些全局检索的信息，可以使RegExp.exec()。
```

#### q、tring.search( )

###### 		-	检索与正则表达式相匹配的子串

```js
#语法
	string.search(regexp)
#参数
	regexp 
		要在字符串string中检索的RegExp对象，该对象具有指定的模式。如果该参数不是RegExp对象，则首先将它传递给RegExp()构造函数，把它转换成 RegExp对象。
#返回值
	string中第一个与regexp相匹配的子串的起始位置。如果没有找到任何匹配的子 串，则返回-1。
#描述
	方法search()将在字符串string中检索与regexp相匹配的子串，并且返回第一个匹配子串的第一个字符的位置。如果没有找到任何匹配的子串，则返回-1。
	search()并不执行全局匹配，它将忽略标志g。它也忽略regexp的lastIndex属性，并且总是从字符串的开始进行检索，这意味着它总是返回string的第一个匹配的位置。
```

## 八、math对象和日期对象

### 1、Math对象

```js
Math.random( )	-	生成随机数
Math.round( )	-	四舍五入
Math.max( )		-	最大值
Math.min( )		-	最小值
Math.abs( )		-	绝对值
Math.ceil( )	-	向上取整
Math.floor( )	-	向下取整
	π			-	Math.PI
Math.sqrt( )	-	计算平方根
```



### 2、Date对象

#### 	a、创建日期对象

```js
var date = new Date();//使用构造函数创建一个当前时间的对象
var date = new Date("2017-03-22");//创建一个指定时间的日期对象
var date = new Date("2017-03-22 00:52:34");//创建一个指定时间的日期对象
var date = new Date(2017, 2, 22, 0, 52, 34);
var date = new Date(1523199394644);//参数：毫秒值
```

#### 	b、获取时间

```js
#使用日期对象的方法获取日期的指定部分
    getMilliseconds();//获取毫秒值
    getSeconds();//获取秒
    getMinutes();//获取分钟
    getHours();//获取小时
    getDay();//获取星期，0-6    0：星期天
    getDate();//获取日，即当月的第几天
    getMonth();//返回月份，注意从0开始计算，这个地方坑爹，0-11
    getFullYear();//返回4位的年份  如 2016
```

#### 	c、日期转为毫秒数(时间戳)



```js
#格林威治时间/格林尼治时间
    Date.parse("2015-08-24") // 获取1970年到设定时间的毫秒数
    new Date().getTime()
    +new Date();
```

### 	d、日期格式化

```js
    date.toLocalString();//本地风格的日期格式
    date.toLocaleDateString(); // 获取日期
    date.toLocaleTimeString(); // 获取时间
```

### 	e、设置时间

```js
    date.setFullYear(2016) // 将日期对象中的年份设置为2016
    date.setMonth(3) // 将日期对象中的月份设置为4月份
    date.setDate(15) // 将日期对象中的日期设置为15号
    date.setHours(12) // 将日期对象中的小时设置为12点
    date.setMinutes(56) // 将日期对象中的分钟设置为56分
    date.setSeconds(23) // 将日期对象中的描述设置为23秒
    date.setTime(0) // 将日期对象设置为0的时间戳
```



## 九、BOM

​		Browser Object Model	-	浏览器对象模型。

#### 1、浏览器的信息

​		浏览器的名称、版本等信息。关于浏览器的信息，window交给了他的子对象navigator去记录。

```js
console.log(navigator.appCodeName); // 返回浏览器的代码名
console.log(navigator.appName); // 返回浏览器的名称
console.log(navigator.appVersion); // 返回浏览器的平台和版本信息
console.log(navigator.cookieEnabled); // 返回指明浏览器是否启用cookie的布尔值
console.log(navigator.platform); // 返回运行浏览器的操作系统平台
console.log(navigator.userAgent); // 返回由客户机发送服务器的user-agent头部的值
使用说明：
	其实navigator对象是属于window对象的，但是window是所有对象的顶级对象，所以通常在写的时候，可以省略掉window。
```



#### 2、浏览器的历史记录

历史记录的操作是window的子对象history。可以操作网页的前进和后退。

```shell
history.back(); # 返回到上一个页面，相当于浏览器的后退按钮
history.forward(); # 前进到下一个页面（下一个页面必须是点击以后的页面），相当于浏览器的前进按钮
history.go(); #可以前进可以后退  go里面的值  正为前进  负数为后退  值的大小为前进或后退的页面数
```

#### 3、浏览器的地址栏信息

​		浏览器的地址栏操作，window对象交给了自己的子对象location对象去处理。

```js
    console.log(location.hash); // 设置或返回从#开始的url --- 锚点
    console.log(location.href); // 设置或返回完整的的url
    console.log(location.search); // 设置或返回url中的参数部分
#方法：
	语法：
	location.assign("要跳转的地址"); # 这个方法是设置要跳转的地址
	location.reload(); # 重新加载本页面
	location.replace() # 使用新地址替换掉旧地址（跳转）
#注：用函数将url编码的数据还原
res = decodeURI(res)  //decodeURI解码 - url编码
```



#### 4、浏览器的弹出

```js
    window.alert("恭喜你！");
    window.prompt("请输入数字：",1);
    window.confirm("你确定要删除吗？")
```



#### 5、浏览器窗口尺寸

```js
    - window.innerHeight - 浏览器窗口的高度
    - window.innerWidth - 浏览器窗口的宽度
#说明：
    1. 这两个属性返回的单位是像素
    2. 这两个属性计算的范围包含滚动条的区域
    3. 可以省略window
```



#### 6、浏览器的事件

```js
#onload事件：当网页中的所有资源都加在完成之后执行这个事件
        window.onload = function(){
            console.log("当网页中所有资源加载完成才打印");
        }
	//使用说明：
		通常是将script标签放到head标签中的时候使用。因为放在head中默认是获取不到body中的内容的，但是有了这个事件后，就可以了。
        
#onunload事件：当浏览器关闭的时候触发这个事件
        window.onunload=function(){
            alert("浏览器要关闭了");
        }
	//使用说明：
		只有在ie浏览器中能看到效果
        
#onscroll 滚动事件：当网页滚动条的位置发生改变的时候触发这个事件
        window.onscroll = function () {
          console.log('浏览器滚动了')
        }
	//使用说明：浏览器要有滚动条才行。

#浏览器窗口改变事件：resize
        window.onresize = function(){
            // 当浏览器的窗口大小发生改变的时候触发这个事件
        }
```



#### 7、浏览器滚动的距离

```js
#获取文档向下滚动的距离，以下两个都可以：
- `document.documentElement.scrollTop `
- `ocument.body.scrollTop`
        window.onscroll = function () {
          var t = document.documentElement.scrollTop;
          console.log(t);
          var t1 = document.body.scrollTop;
          console.log(t1);
        }
//使用说明：
	这两个的区别在于当前文档有没有"doctype"，有就用"document.documentElement.scrollTop"，没有就用"document.body.scrollTop"

#获取页面向右滚动的距离：
    - `document.body.scrollLeft `
    - `ocument.documentElement.scrollLeft`
使用方式同上。

这两个方法在ie和edge下有兼容性问题。
#用兼容写法：
    var t = document.documentElement.scrollTop || document.body.scrollTop;
    var t = document.documentElement.scrollLeft || document.body.scrollLeft;
	//距离可以赋值，如果给向上的滚动距离赋值为0，就实现了回到顶部的效果。但效果时瞬间返回，体验感不好。
```

#### 8、定时器

```js
#延迟执行：
    var timerId = setTimeout(function () {
      console.log('我执行了')
    }, 1000)
    console.log(timerId) // 1
	//使用说明：第一个参数是要执行的函数，第二个参数延迟的时间（单位毫秒）。返回一个数字，表示当前页面中第几个定时器。只执行一次

#每间隔一段时间执行：
    var timerId = setInterval(function () {
      console.log('我执行了')
    }, 1000)
    //使用说明：第一个参数是要执行的函数，第二个参数是间隔的时间（单位毫秒）。返回一个数字，表示当前页面中第几个定时器。不停的执行
    
#关闭定时器：
    clearTimeout(timerId); // 关闭延迟执行的定时器
	clearInterval(timerId); // 关闭间隔执行的定时器
	//使用说明：其实这两个方法可以混用。
```

#### 9、异步操作

```js
`js的异步操作，是在所有同步代码执行完成以后才执行异步代码`
    setInterval()		#延迟执行
    setTimeout()		#每间隔一段时间执行
```

## 十、DOM

### 1、获取元素

```js
#通过document获取节点
    document.getElementById("标签id名"); // 通过标签的id名获取标签
    document.getElementsByTagName("标签名"); // 通过标签名获取标签
    document.getElementsByClassName("标签类名"); // 通类名获取标签 
    document.getElementsByName("标签的name属性的值"); // 通过标签的name属性获取标签
	// 上述4种获取标签的方法，除了通过id可以准确获取到元素，别的方法都是只能获取到元素的集合（类数组/伪数组 - 不是数组）////伪数组可以取下标，可以变遍历  - 不能使用数组的方法
	注：所有dom元素，使用console.log( )  打印出来的都是标签的样子
	如果希望打印出对象的样子使用 console.dir( )
#使用css选择器获取元素：
    documen.querySelector(css选择器); // 获取到匹配css的第一个元素
    documen.querySelectorAll(css选择器); // 获取到匹配css的所有元素
#通过id名直接获取到元素：

	getElements和querySelectorAll获取到的都是伪数组，但是当遍历元素的时候，querySelectorAll可以使用forEach方法遍历，但是getElements不行，只能使用for来遍历。
    获取元素的操作中，通过类名和通过css选择器获取元素的方式在ie中不兼容。
```

### 2、属性操作

```js
#设置属性
自定义属性
    元素.setAttribute(属性名,属性值) # 设置元素的属性  设置的属性覆盖原来的全部属性
    元素.getAttribute(属性名); # 获取元素属性
    元素.removeAttribute(属性名); # 删除元素属性
#元素自带属性
    元素.属性名 = 值;
    console.log(元素.属性名);
```

### 3、内容操作

```JS
#语法：
	元素.innerHTML # 代表元素中的所有内容（包含标签）
	元素.innerText # 代表元素中的文本内容
	表单元素.value
	# 单标签操作内容其实就是在操作元素的属性
```

### 4、样式操作

```JS
# 样式操作
    元素.style.css属性名 = css属性值; # 给标签设置样式
    带有连字符的属性写法--例子：oDiv.style["background-color"] = ""
    oDiv.style.backgroundcolor = ""
```

### 5、html基本结构操作

```
html
    document.documentElement	-	标签
body
	document.body				-	标签
dead
	document.head				-	标签
title
	document.title				-	是内容
```

### 6、元素类名操作

```js
	className
//使用元素的className属性可以操作元素的类名
```

### 7、获取节点

```js
# 获得节点总结

	需要重点掌握的 是  获取  标签元素节点

	所有子元素节点：元素节点.children

	第一个子元素节点：元素节点.firstElementChild

	最后一个子元素节点：元素节点.lastElementChild

	下一个兄弟元素节点：元素节点.nextElementSibling

	上一个兄弟节点：元素节点.previousElementSibling

	获取父元素节点：元素.parentElement

```



### 8、节点属性

```js
#节点类型
	nodeType：元素节点 = 1  属性-2(过时)   注释-8  文本-3  [参考链接](https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeType)
#节点名称
	nodeName
      	说明：元素节点的节点名称是`大写的标签名`；文本节点的节点名称是`#text`；注释节点的节点名称是`#comment`；属性节点的节点名称是属性名。
#节点值
	nodeValue: 
		说明：元素节点没有节点值；文本节点的值就是文本内容；注释节点的内容就是注释的内容；属性节点的内容就是属性的值。
#childNodes/过滤空白节点

```



### 9、节点操作

```js
#创建节点
| 属性名          	| 语法                              | 功能     
| createElement   | document.createElement(元素标签)   | 创建元素节点（创建标签）       
| createAttribute | document.createAttribute(元素属性) | 创建属性节点（创建属性，只有属性名，没有属性值）
| createTextNode  | document.createTextNode(文本内容)  | 创建文本节点（创建了一个内容）      
#插入节点
| 属性名        | 语法                                   | 功能         
| appendChild  | 父节点.appendChild(所添加的新节点)        | 向节点的子节点列表末尾添加新的子节点 
| insertBefore | 父节点.insertBefore(所要添加的新节点，已知子节点) | 在已知的子节点前插入一个新的子节点
#替换节点
	将某个`子节点`替换为另一个
	语法：
	父节点.replaceChild(要插入的新节点，将被替换的老元素);
#复制节点
	根据原来的节点复制一个节点出来
	语法：
		需要被复制的节点.cloneNode(param);
	使用说明：param的值是布尔值，为true时表示复制当前节点及其所有子节点（深复制），为false时，表示仅复制当前节点，缺省值为false（浅复制）
#删除节点
	删除指定元素的某个子节点
    语法：
        父元素.removeChild(要删除的节点);
```

### 10、获取元素样式

```js
#使用style获取元素样式
	style属性只能获取到元素的行内样式。
#通过window对象的getComputedStyle方法：
    语法：
    	window.getComputedStyle(元素).css属性;
	返回一个对象，这个对象中包含了元素所有的样式。如果访问的对象并不存在属性，返回undefind
   #获取元素样式的函数
        function getStyle(ele,attr){
            if(window.getComputedStyle){
                return getComputedStyle(ele)[sttr]
            }else{
                return ele.currentStyle[sttr]
            }
        }
```

### 11、获取元素的大小

```js
# 获取元素的宽度和高度
	语法：
        元素.offsetWidth; # 获取元素的宽度
    	元素.offsetHeight; # 获取元素的高度
	//使用说明：
        1. 这两个属性获取到的元素大小是`包含边框`的。
        2. 这两个属性获取到的结果是数字，方便计算。
        3. 这个属性只能获取不能设置，是只读属性。
#获取定位原点参考的父元素
    语法：
    	元素.offsetParent; # 获取定位需要参考的元素
# 获取元素的位置
    语法：
        元素.offsetLeft; # 获取元素左边的距离
        元素.offsetTop; # 获取元素上边的距离
	//使用说明：
        1. 获取到的值包括外间距，包括设置过的定位的值。
        2. 这个定位过的值其实是自身到offsetParent的距离。
#client获取元素大小
    语法：
        元素.clientWidth; # 获取元素的宽度
        元素.clientHeight; # 获取元素的高度
	//使用说明：
        使用这两个属性获取到的元素的大小是`不包含边框`的大小。
        
#总结获取元素的大小
    元素.offsetWidth  	元素.offsetHeight    ----包含边框
    元素.offsetLeft 		元素.offsetTop       ----位置
    元素.clientwidth		元素.clientHeight    ----不包含边框
```

### 12、DOM获取窗口大小

```js
#BOM有获取浏览器窗口大小的方法：	
        window.innerWidth
        window.innerHeight
		这两个获取窗口大小的时候，包含了滚动条的范围。
#DOM也有获取窗口大小的方法
        document.documentElement.ClientWidth
        document.documentElement.clientHeight
	DOM获取的大小中不包含滚动条的范围。
#DOM获取body的尺寸
        document.body.clientWidth
        document.body.ClientHeight
```



## 十一、事件

### 1、事件三要素

```js
- `事件源`: 谁触发这个事件 (按钮  btn)
- `事件名称`: 触发了什么事件 (点击click事件)
- `事件处理程序`: 事件触发后要执行的代码(函数形式)----可以是有名字的函数，要不要加小括号？不加
- `事件有个特点`：`用完不销毁`  -  造成内存
```



### 2、事件类型

#### 	a、`type`

```js
在事件对象中有个一个属性`type`可以获取到当前事件的类型。
window.onload = function(e){
    var ev = e || window.event;
    console.log(ev.type); // load
}
```

#### 	b、鼠标事件

| 事件        | 描述                             |
| ----------- | -------------------------------- |
| click       | 左键单击                         |
| contextmenu | 右键单击                         |
| dblclick    | 双击                             |
| mousedown   | 左键按下                         |
| mouseup     | 左键弹起                         |
| mouseover   | 鼠标放上去（在子元素上也会触发） |
| mouseout    | 鼠标离开 （同mouseover）         |
| mouseenter  | 鼠标放上去                       |
| mouseleave  | 鼠标离开                         |
| mousemove   | 鼠标移动事件                     |
| mousewheel  | 鼠标滚轮事件                     |

```
	注意：鼠标滚轮事件有兼容性问题，在IE、Chrom中是mousewheel，在FireFox中是DOMMouseScroll，且在FirFox中不能使用on来绑定。在IE和Chrom中向上滚动，事件对象中的wheelDelta是120，向下滚动是-120，在FirFox中向上滚动，事件对象中的e.detail是3，向下滚动是-3。
```



#### c、浏览器事件

| 事件   | 描述     |
| ------ | -------- |
| load   | 加载     |
| unload | 关闭     |
| scroll | 滚动     |
| resize | 大小改变 |



#### 	d、键盘事件

| 事件     | 描述 |
| -------- | ---- |
| keydown  | 按下 |
| keyup    | 弹起 |
| keypress | 敲打 |

键盘事件除了用window可以触发之外，还可以使用document，或者表单元素。总之是可以选中的元素。例如div就不行。



#### e、表单事件

| 事件   | 描述               |
| ------ | ------------------ |
| submit | 提交表单           |
| focus  | 获取焦点           |
| blur   | 失去焦点           |
| change | 内容改变并失去焦点 |
| input  | input的value值改变 |

使用说明：input事件在低版本的IE中不兼容，使用`onpropertychange`代替。



### 3、事件流

```
	每个事件发生的时候，都会有一个触发并执行的过程，也就是事件的传播过程，我们称之为事件流。

	简单来说，事件流就是事件从发生到执行结束的流程。

事件流包含3个阶段：捕获阶段、目标阶段、冒泡阶段

	事件捕获阶段：事件开始由顶层元素触发，然后逐级向下传播，直到目标元素，依次执行其身上绑定的事件。（由外及内找目标元素）

	事件目标阶段(处理阶段)：触发当前自身的事件。（找到目标元素，执行目标元素上的事件）
	事件冒泡阶段：事件由目标元素先接收，然后逐级向上传播，达到最顶层元素，依次执行其身上绑定的事件。（离开目标元素 - 其他目标事件默认再冒泡阶段执行）
	
	事件执行的流程是先捕获阶段——》再目标元素阶段——》最后冒泡阶段。

	目标元素的事件是在目标阶段执行，其他事件会在冒泡阶段执行。每个事件只会执行一次，也就是说如果在冒泡阶段执行了事件，就不会在捕获阶段执行。
```



### 4、事件的绑定方式

```js
#事件可以绑定在行内：
    1、行内绑定事件时候必须加小括号
    2、行内绑定有个好处 - 能传参数
    3、行内获取事件对象 - 传入window.event
#使用on加事件类型绑定事件：
		使用on来绑定事件有弊端：同一个事件只能给一个元素绑定一次。
#解决方案：
	使用`addEventListener()`
   	 语法：
        obj.addEventListener(type,handle,false);   W3C标准浏览器中
        # 参数1：给元素绑定的事件类型，如：click，mouseover。。。
        # 参数2：处理事件的函数
        # 参数3：是否在冒泡阶段执行，true在捕获阶段执行，false在冒泡阶段执行
	//使用说明：这个方法在IE低版本浏览器中不兼容。在IE低版本浏览器中使用`attachEvent()`来代替。
	语法：
        obj.attachEvent('on' + type,handle);
        # type表示事件类型
        # handle表示处理事件的函数
		使用说明：这种写法，有个特点：顺序注册事件，执行的时候是倒叙执行。
 
        
# 通用的绑定和解绑事件
	将三种方式的绑定和解绑综合起来的兼容写法：
#绑定函数
        function bind(ele,type,callback){
            if(ele.addEventListener){
                ele.addEventListener(type,callback,false);
            }else if(ele.detachEvent){
                ele.attachEvent("on"+type,callback);
            }else{
                ele["on" + type] = callback;
            }
        }
	//参数说明：
        - ele：将要绑定事件的对象
        - type：事件类型
        - callback：处理事件的函数
#解绑函数：
        function unbind(ele,type,callback){
            if(ele.addEventListener){
                ele.removeEventListener(type,callback,false);
            }else if(ele.detachEvent){
                ele.detachEvent("on"+type,callback);
            }else{
                ele["on" + type] = null;
            }
        }
```

### 5、事件对象

```js
	浏览器为事件提供了一个对象，用来记录事件的各种具体信息，例如，鼠标点击的位置、鼠标按键的信息、键盘的键码。。。
#兼容所有浏览器的写法：
    btn.onclick = function(e){
        var ev = e || window.event
        console.log(ev);
    }
如果是行内绑定的事件，就将事件对象当做参数传进来即可。`且必须是event`。
```



### 6、阻止事件冒泡

```js
在事件对象中，有一个方法用来阻止事件冒泡，这个方法叫做`stopPropagation`。
#为了兼容IE低版本浏览器，使用兼容写法：
    small.onclick=function(e){
        var ev = e || window.event;
        if(ev.stopPropagation){
            ev.stopPropagation
        }else{
            ev.cancelBubble=true;
        }
    }



```

### 7、事件类型

```js
e.type // 事件的类型
```

### 8、鼠标按键信息

```js
    e.button // 鼠标按键的信息
    0表示左键，1表示鼠标滚轮，2表示右键
```

### 9、按键键码

```js
	e.keyCode // 键盘的键码
#常见的按键码：
    - 13： 回车键（enter）
    - 32： 空格键（space）
    - 数字和字母的键码是数字或字母对应的阿斯克码
#组合按键的判断：
    - `altKey` ：alt 键按下得到 true，否则得到 false
    - `shiftKey` ：shift 键按下得到 true，否则得到 false
    - `ctrlKey` ：ctrl 键按下得到 true，否则得到 false
```



### 10、鼠标坐标点

```js
  从元素内部开始计算的坐标：`offsetX` 和 `offsetY`
    
  相对于浏览器的坐标，使用：`clientX`和`clientY`
    使用说明：不管页面滚动到哪里，都是根据窗口来计算坐标。（不会随着滚动条的滚动而发生改变）

相对于页面的坐标，会随着滚动条的滚动而加大，使用：`pageX`和`pageY`
```



### 11、拖拽效果

```js
鼠标移动事件：`mousemove`
	//注意：获取鼠标坐标位置的时候，不能使用offset来获取，因为offset获取到的值是鼠标在当前元素上的位置，也就是说一开始获取的是大盒子的位置，但是一旦设置了小盒子的位置，鼠标会出现在小盒子上，获取到的位置就成了鼠标在小盒子上的位置了
```



### 12、默认行为

```js
具有默认行为的常见的两个标签

链接<a href="/index.php">点我</a>  往属性href指定的地址跳转
提交按钮<input type=”submit”>   往form表单属性action指定的地址跳转

#阻止默认行为的方法：

1. 给链接地址设置为`javascript:;`或 `javascript:void(0)`

2. 在事件中最后`return false`

3. 通过对象阻止，代码如下：

   function stopDefault(event) {
       var e = event || window.event; 
       if (e.preventDefault){
           e.preventDefault();   // w3c标准浏览器
       }else{
           e.returnValue = false; // IE浏览器
       }
   }

```

### 13、事件委托

```js
	事件委托也叫事件代理（看站谁的角度），使用事件委托技术能避免对每个子节点添加事件监听,相反把事件监听委托给父元素即可，这样可提高绑定事件的性能。

#传统的给每个元素绑定事件：
	代码的缺点：
    1. li标签比较多的时候，性能特别差，毕竟使用for循环相当于绑定了多次
    2. 当动态给li添加元素的时候，新元素没有事件绑定
 分析：当点击按钮给ul添加新元素以后，新元素不具备点击事件，点击没有效果
#解决方案：使用事件委托，将所有子元素的点击事件委托给父元素
**使用事件委托的好处：**
例、<ul>
	<li>首页</li>
	<li>公司介绍</li>
	<li>产品中心</li>
</ul>
<button id="btn">添加新元素</button>
<script>
var oUl = document.getElementsByTagName("ul")[0];
btn.onclick = function(){
	var oNewLi = document.createElement("li");
	oNewLi.innerText = "新闻中心";
	oUl.appendChild(oNewLi)	
}
oUl.onclick = function(e){
	var ev = e || window.event;
	// 获取到单击的目标元素dom对象
	var target = ev.target || ev.srcElement;
	// 判断是否是li标签
	if(target.nodeName == "li"){
		// 完成业务逻辑
		alert(target.innerText);
	}
}
</script>
1. 提高性能(事件委托中并没有使用循环给每个节点设置事件，只给一个父元素ul绑定事件)
2. 后续动态添加的节点也有事件的处理

 注意：事件委托底层就是通过事件冒泡来完成的，先触发父元素的事件，在通过事件对象的target属性找到具体的目标元素，进而在处理目标元素要执行的业务逻辑。
```



### 14、事件对象总结

在行内绑定的事件，在行内传入event，其他事件驱动函数在定义的时候传入自定义参数。在函数中通过获取参数或者window.event来得到事件对象。

| 名称                | 意义                                                       | 使用方式           | 兼容问题            |
| ------------------- | ---------------------------------------------------------- | ------------------ | ------------------- |
| stopPropagation方法 | 阻止冒泡                                                   | e.propagation()    | e.cancelBubble=true |
| preventDefault方法  | 阻止默认行为                                               | e.preventDefault() | e.returnValue=false |
| clientX             | 鼠标点击坐标（相对于浏览器的坐标）                         | e.clientX          | 无                  |
| offsetX             | 鼠标点击坐标（在事件源上的位置）                           | e.offsetX          | 无                  |
| pageX               | 鼠标点击坐标（相对于页面的坐标，会随着滚动条的滚动而加大） | e.pageX            | 无                  |
| target              | 精准的事件源                                               | e.target           | e.srcElement        |
| keyCode             | 键盘码                                                     | e.keyCode          | e.which             |
| type                | 事件类型                                                   | e.type             | 无                  |
| button              | 鼠标按键信息                                               | e.button           | 无                  |



## 十二、正则

### 1、概念：

​		一个用于规范字符串的表达式

### 2、正则表达式的作用

​		1、提取字符串：从指定的字符串中将符合规则部分提取出来

​		2、匹配正则：判断一个字符是否跟指定的规则匹配

​		3、替换字符串：将一个字符串中跟规则匹配的部分替换掉

### 3、正则表达式的创建

```js
#语法：/正则表达式主体/修饰符（可选）
	var reg = new RegExp()	//构造函数方式
	var	reg = /hello/i;		//字面量方式
//使用说明：正则表达式比较特使，不是字符串，不用加引号，但是要有界定符，两边都是斜杠。在斜杠后面可以加一些特定的修饰符
```

### 4、修饰符

| 标志 | 说明                |
| ---- | ------------------- |
| i    | 忽略大小写          |
| g    | 全局匹配，贪婪模式  |
| gi   | 全局匹配+忽略大小写 |

### 5、正则表达式的组成

```
	- 普通字符
	- 特殊字符（元字符）：正则表达式中有特殊意义的字符
```

#### 	a、元字符

##### 			常用的元字符

| 元字符 | 说明                           |
| ------ | ------------------------------ |
| \d     | 匹配数字                       |
| \D     | 匹配任意非数字的字符           |
| \w     | 匹配字母或数字或下划线         |
| \W     | 匹配任意不是字母，数字，下划线 |
| \s     | 匹配任意的空白符               |
| \S     | 匹配任意不是空白符的字符       |
| .      | 匹配除换行符以外的任意单个字符 |
| ^      | 表示匹配行首的文本(以谁开始)   |
| $      | 表示匹配行尾的文本(以谁结束)   |

#### 	b、限定符

| 限定符 | 说明             |
| ------ | ---------------- |
| *      | 重复零次或更多次 |
| +      | 重复一次或更多次 |
| ?      | 重复零次或一次   |
| {n}    | 重复n次          |
| {n,}   | 重复n次或更多次  |
| {n,m}  | 重复n到m次       |

#### 	c、其他

```
[ ] 字符串用括号括起来，表示匹配其中任意一字符，相当于或的意思
[6] 匹配除中括号以内的内容
\	转义字符
|	或者，选择两者中的一个。注意|将左右两边分为两部分，而不管左右两边有多长多乱
()  从两个直接量中选择一个，分组
   eg：gr(a|e)y匹配gray和grey
[\u4e00-\u9fa5]  匹配汉字
```



### 6、匹配字符串

```js
字符串的匹配有两个方法：

- `正则表达式.test(字符串)`：可以匹配为true，否则为false

  /\d/.test('13522336699')   //true

- `search()` 匹配成功 返回下标位置，不成功返回-1

  其实可以理解为查找字符串中符合正则表达式的子字符串的位置

  var str = 'www.baidu.com'
  str.search(/baidu/)   // 4

```



### 7、提取字符串

```js
#语法：`match(正则表达式)`
返回值
存放匹配结果的数组。该数组的内容依赖于regexp是否具有全局性质g。(详细见字符串API-p)

#语法
	regexp.exec(string)
参数
    string 
		要检索的字符串。

返回值
	—个数组，存放的是匹配的结果。如果没有找到匹配，值为null。返回的数组的格式在下面介绍。

抛出
	TypeError 
		调用该方法的对象不是RegExp时，抛出该异常。

var reg = /(a)aa/g; // 贪婪匹配
var str = 'sdafaa aaaa123wer'; 
var arr = reg.exec(str);
console.log(arr); // ["aaa", "a", index: 7, input: "sdafaa aaaa123wer"]
先匹配整体，再匹配小括号
```



### 8、替换字符串

```
语法：`字符串.replace(正则表达式,新内容)`  

var str = 'i love html very much and html is very good';
var reg = /html/g;
var res = str.replace(reg,'js');
console.log(res); // i love js very much and js is very good

引用替换：
    var str = '8/1/2019';
    var reg = /(\d)\/(\d)\/(\d+)/;
    var res = str.replace(reg,"$3/$1/$2");
    console.log(res);
1. 手机号检测
	var reg = /^1[345789]\d{9}$/;
2. 身份证检测
	var reg = /^[1-9]\d{16}([0-9]|X)$/;
3. 中文检测
var reg = /[\u4e00-\u9fa5]/;

```



## 十三、ES5/ES6

### 1、ES5

#### 	a、严格模式

```js
使用方式：在代码最前面加
	"use strict"

优点：
    - 代码规范了
    - 效率提高了
对代码的约束：
    - 不能隐式声明变量
    - 函数形参不能重名
    - 不让函数的this指向window
```

#### 	b、数组新增的方法

```
- indexOf：查找元素在数组中第一次出现的位置下标

- forEach：遍历数组

- map：遍历所有元素，将所有元素给一个函数处理，处理后的新元素组成一个新数组返回

- reduce：归并----

- filter：过滤----将数组中所有满足条件的元素组成一个新数组返回

- some方法先遍历数组，如果至少有一个元素满足条件，则返回true，否则返回false。

- every方法先遍历数组，判断所有元素是否满足条件，返回布尔值

- find方法返回数组中满足条件的 第一个值 ，找不到元素则返回false

- findIndex方法返回数组中满足条件的  第一个值的下标 ，找不到元素则返回-1
```

### 2、ES6

#### 	a、定义变量

```js
#let是声明变量的关键字，特点：
    1. 不允许重复声明
    2. 不存在预解析
    3. 在大括号中声明的变量只能在大括号中使用，如if、for的大括号中声明的变量
  //使用场景：如果在一个循环中使用了事件、异步操作 - 建议将循环中的变量使用let定义
  
#const是声明常量的，特点：
    1. 不允许重复声明
    2. 不允许重新赋值（可以给对象中新增属性）
    3. 声明的时候必须赋值
    4. 不存在预解析
    5. 在大括号中声明的变量只能在大括号中使用，如if、for的大括号中声明的变量
```



#### 	b、箭头函数 - [链接](https://juejin.im/post/6844903573428371464)

```js
es6中的箭头函数是用来简写函数的
规则一：箭头函数只能用赋值式写法，不能用声明式写法
规则二：如果参数只有一个，可以不加括号，如果没有参数或者参数多于一个就需要加括号
规则三：如果函数体只有一句话，可以不加花括号
规则四：如果函数体没有括号，可以不写return，箭头函数会帮你return
		记住：函数体的花括号与return关键字同在。
带参数的写法：
    let fn = function(a,b){
        console.log(a+b);
    }
使用箭头函数改写
	let fn = (a,b)=>{console.log(a+b);}
    
#注意：如果只有一个形参的时候，小括号可以省略：
    let fn = function(a){
        console.log(a);
    }
使用箭头改写
	let fn = a = > {console.log(a);}

#注意：如果代码块中只有一行代码，箭头函数可以省略大括号，并将这行代码作为返回值
    let fn = function(a){
        return a + 1;
    }
箭头函数的写法
	let fn = a = > a+1;

###箭头函数使用注意事项：
    1. 箭头函数中的this比较混轮，所以在函数和方法中使用到this的时候，就不要用箭头函数，箭头函数的this表示他上一行代码所在的
    2. 箭头函数中没有arguments
#箭头函数的特性一：默认绑定外层this
	箭头函数会默认帮我们绑定外层this的值，所以在箭头函数中this的值和外层的this是一样的。
#箭头函数的特性二：不能用call方法修改里面的this
//这表示多层对象嵌套里箭头函数里this是和最最外层保持一致的。
```



#### 	c、函数默认值

```js
以前的函数不能有默认值，es6的函数中可以定义默认值：

    function add(a,b=2){
        return a + b;
    }
    console.log(add(5));

可以用箭头函数改写：
    let add = (a,b=2) => a+b;
    console.log(add(5));
```



#### 	d、模板字符串

```js
#1.以前的字符串，只能放在一行，不能分行定义 - 模板字符串就可以
#2.模板字符串中可以识别变量${变量}
var str = `
    <table border=1>
        <tr>
            <td>`+a+`</td>
            <td>${b}</td>
            <td>${c}</td>
        </tr>
        <tr>
            <td>${d}</td>
            <td>${e}</td>
            <td>${f}6</td>
        </tr>
    <table>
`
console.log(str);
```



#### 	e、字符串方法

```
1. startsWith()  是否以谁开头，返回布尔值
2. endsWith()   是否以谁结尾，返回布尔值
3. includes()    判断一个字符串或数组是否包含一个指定的值
   'Blue Whale'.includes('blue'); // return false
```

#### 	f、解构赋值

```js
#解析一个数据结构并赋值，可以快速的从对象或数组中取出需要的内容，对象使用大括号，数组使用中括号
#解构对象
	之前从对象中取到内容的方式
        let obj = {
            name:"张三",
            age:12,
            sex:"男",
        }
        let name = obj.name;
        let age = obj.age;

#解构的方式：
    let obj = {
        name:"张三",
        age:12,
        sex:"男",
    }
    let {name} = obj;
/*
表示从obj中获取name属性，并赋值给声明的name变量
*/

#使用说明：
    1. obj必须是一个对象
    2. obj中必须有name属性

#还可以一次性解构多个变量：
    let obj = {
        name:"张三",
        age:12,
        sex:"男",
    }
    let {name,age} = obj; // 声明并赋值了两个变量

#可以将变量名换成一个别的名字：
    let obj = {
        name:"张三",
        age:12,
        sex:"男",
    }
    let {name:username,age:a} = obj; // 将obj的name属性值赋值给username变量，age属性值赋值给变量a

#多级解构：
    let obj = {
        name:"张三",
        age:12,
        sex:"男",
        wife:{
            name:"翠花",
            age:11,
        }
    }
    let {wife} = obj;
    let {name} = wife;
// 写为一行
	let {wife:{name:wname}} = obj;
# 解构数组
    let arr = [1,2,3];
    let [num1] = arr; // 从数组中拿出第一个元素赋值给num1变量

#使用说明：
     解构数组的时候是按顺序取出数组中的值，解构一个变量，只能拿到第一个元素

#解构多个元素：
    let arr = [1,2,3];
    let [num1,num2] = arr; // num1 = arr[0]   num2 = arr[1]

#多维数组解构：
    let arr = [1,2,3,[4,5,6]];
    let [a,b,c,[aa,bb]] = arr;
    console.log(aa,bb); // 4 5

#利用结构交换两个变量的值：
    let num1 = 1;
    let num2 = 2;
    [num2,num1] = [num1,num2]

```



#### g、展开运算符

```js
#将一个数组展开为多个变量赋值给多个形参
    let arr = [1,2,3];
    function fn(a,b,c){
        console.log(a,b,c); // 1 2 3
    }
	#fn(...arr);
```

#### h、合并运算符

```js
#将多个实参合并为一个数组
    function fn(...arr){
        console.log(arr);
    }
    fn(1,2,3); // [1,2,3]

#箭头函数中没有arguments，可以使用合并运算符来模拟arguments
    var fn = (...arr) => {console.log(arr)};
    fn(1,2,3); // [1,2,3]

```

#### i、对象的简写方式

```js
    let name = '张三';
    let age = 12;
    let obj = {
        name,
        age
    }
    console.log(obj);
#如果对象的属性名和变量名同名，则可以光写属性名
```

### 3、其他

#### 	a、检测数据类型

​		之前使用typeof检测数据类型，但这种方式只能检测基本数据类型。在判断数组或对象的时候不能准确判断。

有一个比较长的方法，可以检测所有数据类型：

```shell
Object.prototype.toString.call(被检测的数据类型)
```

#### 	b、this关键字

```js
每个函数内容都有一个关键字叫做this。不同的情况下，this代表的内容也是不一样的。

#1. 普通函数中的this代表window对象
   function fn(){
       console.log(this);
   }
   fn(); // window

#2. 定时器中的this代表window
   var obj = {
       eat:function(){
           setTimeout(function(){
               console.log(this);
           });
       }
   };
   obj.eat(); // window

#3. 自调用函数中的this代表window
   document.querySelector("button").onclick=function(){
       (function(){
           console.log(this);
       })()
   }
   // window

#4. 对象方法中的this代表调用这个方法的对象
   var obj = {
       eat:function(){
           console.log(this);
       }
   };
   obj.eat(); // obj

#5. 事件函数中的this代表当前事件的事件源
   document.querySelector("button").onclick=function(){
       console.log(this);
   }
   // <button>按钮</button>

#6. 箭头函数的this在定义箭头函数的时候就知道了，代表上一行代码的this
   document.querySelector("button").onclick=function(){
       // 这里的this代表button按钮，所以箭头函数的this也是button按钮
       setTimeout(()=>{console.log(this);});
   }
   // <button>按钮</button>

#重点：函数内部的 this 只和函数的调用方式有关系，和函数的定义方式没有关系。箭头函数在定义的时候就知道this代表什么**
```



### 4、上下文调用模式

```js
	也叫作方法借用模式。任何函数都能调用call、apply、bind这三个`方法`。这三个方法主要用于改变函数中this的指向。
    #call
	call方法不仅可以用来调用函数，还可以指定调用函数的this指向。call的第一个参数就可以改变函数内的this指向：
        function fn2(){
        console.log(this);
        } 
        fn2.call([1,2,3]); // 打印结果就是这个数组
    这时候的this就变成了call的第一个参数，也就是这个数组
	call的参数可以有若干个，第一个参数用来改变函数内的this指向，其余的函数是作为调用函数的实参
        function fn3(num1,num2){
        console.log(this);
        console.log(num1+num2);
        }

        // fn3(10,20);
        var arr = [10,20];
        fn3.call(arr,arr[0],arr[1]); //结果： Array  30
    如果call没有参数或第一个参数为null，那么函数中的this执行window
    
    #apply
    apply的作用和call是一样的，区别只在于写法，apply只有两个参数，第二个参数是一个数组或者伪数组
        function fn5(num1,num2){
        console.log(this);
        console.log(num1+num2);
        }
        var arr = [10,20];
        fn5.apply(null,arr); // window  30
#apply的特性： apply的平铺性： 将数组的中每一项取出来，作为借用函数的实参
	什么时候用什么方法（call、apply）
        1. 如果参数比较少的情况下，使用call比较方便
        2. 如果参数已经存放在数组中，使用apply
#### bind
	语法：` var fn2 = fn.bind(thisArg);`
	作用： bind会创建并返回一个新的函数， 新的函数和借用的函数是一模一样的, 但是新函数内的this已经被改变成了bind的参数thisArg
	bind 是不会去调用fn函数的，不像call、apply会去调用函数。bind会创建并返回一个新的函数，和借用的函数是一模一样的，但是新函数内部的this变成了指定的对象
//使用场景：经常用于将定时器的this（window）变成指定的对象：
    var obj = {
        name:'张三',
        lover:'李四',
        sayLove:function(){
            // 使用bind将属于window的setTimeout变成当前对象的setTimeout
            setTimeout(function(){
                console.log(this.name+"爱"+this.lover);
            }.bind(this),500); 
        }
    }
    obj.sayLove(); // 张三爱李四
//如果没有bind的话，打印结果是：""爱undefined
```

### 5、json

#### 	a、json对象

```js
js中的数组或者对象都可以是json对象
```

#### 	b、json字符串

```js
json格式的字符串叫做json字符串
```

#### 	c、字符串和对象的转换

```js
`JSON.stringify` 是将 js 的对象或者数组转换成为 json 格式的字符串
`JSON.parse`  是将 json 格式的字符串转换为 js 的对象或者数组
```

### 6、伪数组

```js
#伪数组是一个对象。
	这个对象中必须有length属性，如果length不为0，那么这个对象中必须有下标和对应的数据。在console中length显示是实的
#常见的伪数组有：
    arguments
    DOM对象列表----HTMLCollection

#伪数组转为数组的方法：
	Array.prototype.slice.call(fakeArray) 
也可以进行遍历放入数组中。
```



## 十四、面向对象

### 1、概念

​	面向对象不是一种语法，是一种编程的思想。

​	s中的面向对象编程，就是<font color="red">**创建对象，给对象添加属性和方法**</font>

### 2、创建对象

```js
#直接创建：
		var obj = {}
	这种创建也叫字面量的方式。字面量其实就是你一眼看到就能知道具体是什么是多少的值。比如变量x，你看到后不知道x是什么类型，是什么值，但是3你就知道这是个数字类型，值是3，那么3就是字面量。
    
#构造函数方式创建：
		var obj = new Object();
	Object是一个系统提供的构造函数，这个构造函数专门用来创建对象使用的。

#给这样的对象添加属性和方法，语法：
    对象.属性名 = 值;
    对象.方法名 = 函数;
```

### 3、工厂函数创建对象

```js
#定义一个函数，每次调用都能得到一个对象
        function createObj(name,age,sex){
            var obj = new Object();
            obj.name = name;
            obj.age = age;
            obj.sex = sex;
            return obj;
        }
        var obj1 = createObj("张三",12,"男");
        var obj2 = createObj("李四",13,"女");
        var obj3 = createObj("王五",11,"女");
//这种调用就能创建对象的函数，叫做工厂函数。创建出来的每个对象的结构一致
#优点：
	可以同时创建多个对象
#缺点：
	创建出来的没有具体的类型（比如是Array和Number），都是object类型的，但我们看到自己的对象只是object，不知道具体是什么类型。
```

### 4、自定义构造函数

```js
#构造函数和普通函数不同的地方在于使用new的时候，中间发生了很多看不见的过程：
    1. 创建了一个新对象
    2. this指向了这个新对象（新对象就有了属性，创建了属性）
    3. 执行构造函数，也就是调用了这个函数（给对象添加属性和方法，给属性和方法赋值）
    4. 返回这个新对象
//使用new构造函数来创建对象的过程称之为`实例化`
#构造函数注意事项：
    1. 构造函数天生就是用来创建对象的，所以必须和new配合使用，否则就不具备创建对象的能力
    2. 构造函数内部不能有return关键字，因为构造函数会自动返回对象。如果返回基本数据类型，和不加效果一样，如果返回复杂数据类型，构造函数就没意义了。
    3. 如果new的时候，不需要参数，那么小括号可以省略
    4. 人们通常将构造函数的首字母大写
#此时的构造函数有个缺点：
	一个构造函数中给对象添加了一个方法，然后创建了两个对象，这两个对象都有这个方法，并且这两个方法一模一样，但是这个方法在内存中却是两个空间，这样对于内存空间来说有点浪费，因为两个对象的方法是一样的但是却占了两个空间。解决方法 - 原型         

```

### 5、原型

​		概念：<font color="red">**任何函数在创建好的时候，浏览器会分配一个对象给这个函数，通过函数的prototype可以访问到这个对象。这个对象叫做原型对象，简称原型。通过new构造函数实例化出来的对象默认可以访问到这个对象的属性和方法。**</font>

​		给这个原型添加属性和方法，使用实例对象可以访问到。

```js
    function Person(){

    }
    Person.prototype.name = '赵六';
    Person.prototype.say=function(){
        console.log("说话");
    }
    var obj = new Person();
    console.log(obj); // 赵六
    obj.say(); // 说话
```

​		<font color="red">对象访问属性的时候，先找自己有没有，自己有就直接使用，自己没有就去原型对象上找。</font>

​		我们以后创建对象就使用构造函数，多个对象要使用同一个方法或属性，就把这个属性或方法绑定到原型上。

实例对象想访问到原型对象，可以使用`__proto__`属性。

​		<font color="red">**任何对象都有一个属性叫做`__proto__` 这个属性可以访问到对应的构造函数的原型对象，也就是构造函数的`prototype`属性的值**</font>

| 实例原型构造函数的关系                                       |
| ------------------------------------------------------------ |
| ![](https://raw.githubusercontent.com/sady-19/MdImage/main/img/202203281139080.png) |

### 6、构造器

​		每一个原型对象天生带有一个属性叫做`constructor`，这个属性指的是这个原型对象所属的构造函数。

```js
function Person(){
    
}
var obj1 = new Person();
console.log(obj1.__proto__.constructor === Person); // true  
console.log(obj1.constructor === Person); // true  obj1对象中没有constructor属性，所以去原型对象上找
```

### 7、原型链

​		对象访问属性的时候，如果自己么有，就去原型对象上找，找到了访问。那如果找不到怎么办？

​		对象天生就有一个属性叫做`__proto__`，那么，原型对象也是对象，他也有这个属性，也就是说，原型对象也有原型自己的构造函数和原型对象。

```js
    function Person(){

    }
    var obj = new Person(); // 通过构造函数创建了对象obj
    var proto = obj.__proto__; // 通过实例对象访问到原型对象
    console.log(proto);
原型也有原型
```

| 原型链                                                       |
| ------------------------------------------------------------ |
| ![](https://raw.githubusercontent.com/sady-19/MdImage/main/img/202203281139081.png) |

​		这样向上的一条链式结构，我们称之为原型链。

对象查找属性的规则：

​		先在自己身上找,如果有,直接使用,如果没有,顺着原型链往上找,找到了就使用,找不到就继续往上找,如果找到了null,都没有的话,就返回undefined;

但是<font color="red">**对象属性赋值和原型没关系，有就修改，没有就增加。**</font>